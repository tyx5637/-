# 小田的秋招

# 项目介绍

产品研发和工程架构部

## Pico bbs

1. jupiter
   1.  基于react的渐进式现代Web开发框架，从三种工程方案出发（应用工程方案，模块工程方案，monorepo工程方案），支持全链路的前端研发。

   2. 应用工程方案：
      - Cli，servert，runtime
   3. 模块工程方案：
      - 用于开发可复用模块，主要提供编译构建的能力，插件方面则是主要提供了调整编译构建配置的 Hook。
   4.  特点：https://juejin.cn/post/7002111539733872648

   5. 应用初始化可以对项目进行简单的配置，比如开发语言，包管理工具等。在初始化的过程中也不会内置所有官网的功能，如果内置功能不满足需要也可以使用官方插件来扩展功能。在创建项目之后我们可以通过命令行字懂的开启jupiter官方支持的功能，比如国际化i18n，less/sass支持等
   6. 我们也可以在jupiter初始化模板项目的基础上通过生成器插件对模板进行增加，删除，修改的方法
   7. unbundle模式极速开发，会极大提升服务启动的速度。有使用 Webpack 启动需要 200s 左右的项目，使用 Unbundled 后只花费 10s，开发调试**提速 20 倍**。
   8. 服务端渲染：在jupiter.config.js文件中配置server:{ssr: true}}即可

1. Hybird
   1.  Pico vr助手是一个Hybrid app。将APP的一部分需要动态变化的内容通过h5来实现，通过原生的网页加载控件webview（安卓）或WKWebview（ios）来加载h5页面，h5页面可以随时改变不用发版，动态化满足需求，同时H5的页面只需要一次开发就可以在android和ios两个平台运行。

   2. 优点：可以跨平台，调试方便，维护成本低，不用发版解决问题
   3. 缺点：需要多端配合，不适用交互性强的app

1. webview：
   1.  在做移动端h5开发时，需要与native之间进行交互，而在native中，h5的承载容器为webview，核心是使用webview控件实现加载url。

   2.  webview就是用来展示网页的view组件。WebView 是手机中内置了一款高性能 Webkit 内核浏览器，在 SDK 中封装的一个组件。不过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。可以理解为是页面里面的iframe。

1. Jsb
   1.  给js提供调用native功能的接口，是native与非native之间的桥梁。核心是构建native与非native间消息通信的通道，是双向通信的

   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA0ZThhYWZhNjNkZTE4NTg2YTliZDgzY2E5YjE3OTRfS2hvdVJpaW50aU9QZ1dRRFExa1FvVlM2UWRxVVQ2N0pfVG9rZW46Ym94Y25tMlNIUldUakV5MUJuZFFQUG9YSGFjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   3.  [深入浅出JSBridge:从原理到使用 - 掘金](https://juejin.cn/post/6936814903021797389)

   4.  **native=>web**

   5.  将拼接的js代码字符串，传入js解析器（webview）执行

   6.  **web=>native**

   7. 拦截webview请求的url schema
      1.   Native加载WebView之后，Web发送的所有请求都会经过WebView组件，所以Native可以重写WebView里的方法，从来拦截Web发起的请求，我们对请求的格式进行判断：

      2. 如果符合我们自定义的URL Schema，对URL进行解析，拿到相关操作、操作，进而调用原生Native的方法
      3. 如果不符合我们自定义的URL Schema，我们直接转发，请求真正的服务
      4.   web发送URL请求的方法的方式：

      5. a标签
      6. location.href
      7. 使用iframe.src
      8. 发送ajax请求
   8. 向webview中注入js api
      1.   这个方法会通过webView提供的接口，App将Native的相关接口注入到JS的Context（window）的对象中，一般来说这个对象内的方法名与Native相关方法名是相同的，Web端就可以直接在全局**window**下使用这个暴露的全局JS对象，进而调用原生端的方法。

1. 埋点
   1.  埋点是用来进行数据采集的，针对特定用户行为或事件进行捕获，处理以及发送的相关技术及其实施过程。埋点是数据的来源，采集的数据可以分析网站/APP的使用情况，用户行为习惯等，是建立用户画像，用户行为路径等数据产品的基础。（目前pico使用的是代码埋点的方式）

   2.  手机助手中的埋点需要与客户端同学配合进行工作，所以是hybrid页面中的埋点由客户端进行上报，前端只是调用了jsb将参数传递过去

   3. ```JavaScript
      hybrid/hooks/useAppTrackHook.ts
      /** 事件处理中心 */
      function useAppTrackHook() {
        const eventDataRef = useRef<any>(null);
        useEffect(() => {
          const picoEvent = eventDataRef.current;
          if (!picoEvent) {
            return undefined;
          }
          // click_report埋点
          const clickReport = picoEvent.on('click_report', ({ data }) => {...});
          return () => {
            clickReport();
          };
        }, [eventDataRef.current]);
        return [eventDataRef];
      }
      export default useAppTrackHook;
      
      _app.tsx——页面根组件
      import useAppTrackHook from '../hooks/useAppTrackHook';
      
      const App = ({ Component, ...pageProps }: { Component: React.ComponentType }) => {
      const [eventDataRef] = useAppTrackHook();
          return (
          // 当我们需要传递参数时也可以在tsx中包裹<DataEventProvider></DataEventProvider>
              <DataEventProvider ref={eventDataRef} evtData={{ root: 'hybrid', appid: '264482' }}>
                <div id="app">
                  <Component {...pageProps} />
                </div>
              </DataEventProvider>
          )
      }
      hybrid/pages
      export default ()=>{
          const dataEventContext = useContext(DataEventContext);    
          const onUserClick = user => {
              dataEventContext.trigger('click_user', {
                user,
              });
          };
      }
      
      DataEventProvider/index.tsx
      import React, { forwardRef, PropsWithChildren, useContext, useEffect, useImperativeHandle, useMemo } from 'react';
      
      import CustomEventNode from './CustomEventNode';
      
      interface DataEventProps {
        evtData: any;
        /** block 状态, 为 true 时暂存当前事件,待 block 状态解除再发送 */
        block?: boolean;
      }
      
      const rootEventNode = new CustomEventNode();
      
      /** 社区中台组件全局配置Context */
      export const DataEventContext = React.createContext<CustomEventNode>(rootEventNode);
      
      /** 社区中台事件中心节点 */
      const DataEventProvider = forwardRef<CustomEventNode, PropsWithChildren<DataEventProps>>(({ evtData, block, children }, ref) => {
        const evtObj = useMemo(() => new CustomEventNode(), []);
        const parentEvtObj = useContext(DataEventContext);
      
        useEffect(() => {
          evtObj.setParent(parentEvtObj);
        }, [parentEvtObj, evtObj]);
      
        useEffect(() => {
          evtObj.block = Boolean(block);
        }, [block, evtObj]);
      
        useEffect(() => {
          evtObj.evtData = evtData;
        }, [evtData, evtObj]);
      
        useImperativeHandle(ref, () => evtObj, [evtObj]);
      
        return <DataEventContext.Provider value={evtObj}>{children}</DataEventContext.Provider>;
      });
      
      export default DataEventProvider;
      
      DataEventProvider/CustomEventNode.ts
      import { cloneDeep } from 'lodash';
      
      const EventListenSymbol = Symbol('EventListen');
      const EventCatchSymbol = Symbol('EventCatch');
      const InnerProp = Symbol('InnerProp');
      
      interface EventData {
        name: string;
        data: any;
        context: any[];
      }
      
      interface EventListenRecord {
        handle: (data: EventData) => void;
        once: boolean;
      }
      
      let i = 1;
      
      interface EventCatchItem {
        evtName: string;
        evtData: any;
      }
      class CustomEventNode {
        /** 事件监听池 */
        [EventListenSymbol]: { [key: string]: Set<EventListenRecord> };
      
        /** 缓存事件池 */
        [EventCatchSymbol]: Set<EventCatchItem>;
      
        /** 内部状态 */
        [InnerProp]: {
          id: number;
          /** block 状态, block 状态下 trigger 的事件会被暂存, 带状态解除再发出 */
          isBlock: boolean;
          parent: null | CustomEventNode;
          eventData: any;
        };
      
        constructor() {
          this[InnerProp] = Object.create(null);
          this[EventListenSymbol] = Object.create(null);
          this[EventCatchSymbol] = new Set();
      
          this[InnerProp].id = i++;
          this[InnerProp].isBlock = false;
          this[InnerProp].parent = null;
          this[InnerProp].eventData = {};
      
          if (process.env.NODE_ENV === 'development') {
            window.CommunityEventNodes = window.CommunityEventNodes || [];
            window.CommunityEventNodes.push(this);
          }
        }
      
        get id() {
          return this[InnerProp].id;
        }
      
        get evtData() {
          return this[InnerProp].eventData;
        }
      
        set evtData(val) {
          this[InnerProp].eventData = val;
        }
      
        get block() {
          return this[InnerProp].isBlock;
        }
      
        set block(status: boolean) {
          const oldStatus = this[InnerProp].isBlock;
          this[InnerProp].isBlock = status;
      
          // 解禁
          if (!status && oldStatus) {
            // 把缓存事件都发出并情况事件缓存池(注意死循环), 同步代码应该没问题
            this[EventCatchSymbol].forEach(eventItem => {
              this.trigger(eventItem.evtName, eventItem.evtData);
            });
            this[EventCatchSymbol].clear();
          }
        }
      
        setParent(parent: CustomEventNode) {
          this[InnerProp].parent = parent;
        }
      
        getContext(): any[] {
          const ctx = this[InnerProp].parent?.getContext() || [];
          ctx.unshift(this[InnerProp].eventData);
          return ctx;
        }
      
        /** 添加事件监听, 仅监听一次 */
        once(evtName: string, fuc: (evt: EventData) => void): () => void {
          this[EventListenSymbol][evtName] = this[EventListenSymbol][evtName] || new Set();
          this[EventListenSymbol][evtName].add({
            handle: fuc,
            once: true,
          });
      
          return () => {
            this.off(evtName, fuc);
          };
        }
      
        /** 添加事件监听 */
        on(evtName: string, fuc: (evt: EventData) => void, once = false): () => void {
          this[EventListenSymbol][evtName] = this[EventListenSymbol][evtName] || new Set();
          this[EventListenSymbol][evtName].add({
            handle: fuc,
            once,
          });
      
          return () => {
            this.off(evtName, fuc);
          };
        }
      
        /** 取消事件监听 */
        off(evtName: string, fuc: any) {
          if (!this[EventListenSymbol][evtName]) {
            return;
          }
          this[EventListenSymbol][evtName].forEach(item => {
            if (item.handle === fuc) {
              this[EventListenSymbol][evtName].delete(item);
            }
          });
        }
      
        /** 抛出事件 */
        trigger(evtName: string, val: any, context?: any[]) {
          if (!evtName) {
            return;
          }
      
          if (this[InnerProp].isBlock) {
            this[EventCatchSymbol].add({ evtName, evtData: cloneDeep(val) });
            return;
          }
      
          // 带上自己的上下文, 构造新 context
          const newContext = Array.from(context || []);
          newContext.push(this[InnerProp].eventData);
      
          // 执行监听函数
          const actions = this[EventListenSymbol][evtName];
          if (actions) {
            actions.forEach(action => {
              const { handle, once } = action;
              try {
                handle.call(this, {
                  name: evtName,
                  data: val,
                  context: newContext,
                });
              } catch (e) {
                console.error(e);
              }
              if (once) {
                actions.delete(action);
              }
            });
          }
      
          this[InnerProp].parent?.trigger?.(evtName, val, newContext);
        }
      }
      
      export default CustomEventNode;
      ```

forwardRef：转发ref，它会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。其主要作用是：

- 转发refs到dom组件
  -  当 React 附加了 ref 属性之后，ref.current 将直接指向 DOM 元素实例

  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYwMWVjNjc2NDI5MjhjM2RiNGRhYTAyZDZkMzUzZjBfRWVvc2paYkswbk9HOTVPZlBObEpLQkpQUk9lbG5JckhfVG9rZW46Ym94Y244d0N4Z0gwVHdlQnJJdWd0dUVhTFJjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## Pico开发者社区

1. 管理页面搭建

   1.  使用arco-design的layout组件进行搭建

   2.  管理页面中遇到的几个问题

   3. 页面加载慢，编辑某一列内容后重新获取数据时页面卡死，这个时候使用tooltip组件获取具体某一项中的数据，解决问题

   4. 服务端写接口异步的解决方案

      1.   前端调用服务端写接口后得到服务端请求成功后调用读接口，拉取不到写入的数据。目前的解决方案是前端mock，settimeout300毫秒再获取数据

      2. > 前端mock？
         >
         > 前端mock的意思是前端调用接口后，关于接口调用后产生什么效果由前端代码手动写变更，比如点赞场景，点赞后数值加1。
         >
         > 优点：
         >
         > 即时交互的体验，无延时
         >
         > 缺点：
         >
         > - 没有经过服务端返回的成功率验证，前端的修改不能保证落库，只是用户视觉展示
         >
         > - 开发维护成本高，服务处理的结果有一套逻辑，前端需要理解这个逻辑并且重写一份，增加开发成本，如果增加完备的处理，还是需要等服务结果反馈有新的交互链路告知用户，还会再增加成本
         >
         > 使用的场景：
         >
         > - 就及时反馈的用户体验要求很高的场景，比如点赞，如果等待接口返回再修改状态，那么用户可能点击后感受到一定的延迟，才有点赞效果触发
         >
         > - 用户行为允许非百分百的成功率，比如前端修提前改点赞状态，如果此次点赞行为并没有成功，用户不会骂娘。用户发现的时候可能觉得自己是不是记错了，或者再点一次。
         >
         > - 小局部修改：点赞状态相比于内容详情

1. starling接入
   1.  主要遇到的问题是18n.init是一个异步的方法，我们需要保证在使用I18n实例之前，它已经被初始化，在初始化之前使用实例的时候会报错

   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQxZWM0ZjY1ZmRlOWM2N2U1YjM3ZGVhMjVlYjc0OGVfZUZMaTRLc0FEcXRyQnhtS3ZsNnU5alB4V2F0cjVOanlfVG9rZW46Ym94Y25sSTVIUnNGQ2FXMGV0ZzdKN2J2VnVoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   3.  pico开发者社区：

   4. ```JavaScript
      import { I18n } from '@ies/starling_intl';      
      import Starling from '@ies/starling_client';
      
      // 初始化i18n实例
      // 详细配置见：https://starling.bytedance.net/open/content/9163/111688
      I18n.init({
       // ...一些配置
      });
      // 新建 Starling Client 实例并拉取文案
      // 详细配置见：https://starling.bytedance.net/open/content/9163/111694
      const starling = new Starling({
        // ...一些配置
      })
      
      const initStarling = starling.load().then((texts: any) => {
        // 方法介绍参考 https://www.i18next.com/overview/api
        I18n.addResourceBundle('当前语言', 'translation', texts);
        I18n.setLang('en');
        // ensure I18n init complete
        return new Promise(resolve => setTimeout(resolve));
      });
      
      const App = ({ Component, ...pageProps }: { Component: any }) => {
        const [starlingInited, updateStarlingInited] = useState(false);
        // i18n.init是一个异步的方法，我们需要保证在使用I18n实例之前，它已经被初始化
        useEffect(() => {
          initStarling.then(() => updateStarlingInited(true));
        });
        return (
          {!starlingInited ? (
            // 可以设置一个loading效果
            ) : (
            // 需要渲染的dom
            )
          }
        )
      }
      ```

1. 通过游标cursor来查询数据

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg0NDU5NTNkNDM1MWIwNTI0YTUwOTJlYzBjODI3NjRfSHZpNGdwdjJtNzJvczlDQ3lhOVhnUFpZeGtGQW10MUFfVG9rZW46Ym94Y25ha3dzekZ5MnBSUlhiM3ZxVWtZYXlkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 中台组件

1. 组件化
   1. 为什么要组件化？
      1.   早期的页面是比较简单的，现在的网页内容动态化，依靠服务提供真实内容，交互性极强，交互反馈要求高，功能性越来越强，组件化可以很好的解决如下问题帮助我们开发

      2. 项目复杂度增加，一个页面处理的内容过多
      3. 重复性劳动多，效率低
      4. 质量差难以维护
   2. 组件的基本特征
      1. 高内聚低耦合
      2. 影响范围可控，包含样式和逻辑
      3. 功能独立，与外界的连接点有限
      4. 标准的结构
      5. 组件包含属性，方法，事件这些固定概念，外部交互通过这些内容使用组件
      6. 标准的迭代管理
   3. 组件的结构
   4. ​       组件通常有以下几个部分：UI，attribute/property，method，life cycle，status

   5.   UI：一些容器组件是没有UI的

   6.   我们把 UI 主要分成两个部分，内容和样式。这样似乎与 HTML 和 CSS 分别对应上了，其与传统的开发有什么区别呢？区别就在于我们在上文提到的隔离。但是使用各种方式，比如在打包阶段做一些额外的处理，帮助我们做到隔离，通常按照标准的写法是不会对外部产生不可控的影响的。

   7.   举例：vue 的单文件组件，template 和 style 部分就对应了内容和样式，也可以描述为渲染和样式。template 限制了只能书写组件的内容，style 加上 scoped 配置。如下图，在渲染成具体的 dom 的时候，vue 会给对应元素加上唯一标志，并在选择器中带上这个标志。以这种方式来保证组件间样式的隔离。

   8. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVhYTg3MDVlNjM4NTdhNmIzOGJhOTMyZGM0NjkxN2ZfaXpidWh2cmNPNEdIamNDNk5aeVY4ZE5wcnpNUHR2YklfVG9rZW46Ym94Y25obU13WVc1ZDRtNWVYREd3dlFpaGZEXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   9.   attribute/property，method，status：这四个部分与组件的功能逻辑紧密相关。attribute 与 property 是初始化时的配置，status 是运行时的内部状态变量，method 是提供的方法。从代码角度来看，组件内所有运行时内容都可以归到这几类中。

   10. > ​        为什么会有 attribute 与 property 两个部分用来描述配置呢？我们认为组件是对 HTML 元素的扩展，attribute 便是承接与 HTML 元素的设计。HTML 的元素在书写的时候可以添加 attribute，但是受限于形式 attribute 仅是字符串格式，因为我们是写在 html 文件中的。但是我们都应该有经验，对一个组件的配置不可能只有字符串的，比如，我们在使用 swiper 轮播组件时，我们可以配置轮播动画的时长，是否自动轮播等。这时候我们往往会使用 js 的形式，并传一个对象进去。这种通过 js 来配置组件时传的值，叫做 property。attribute 与 property 通常是有对应关系的。我的建议是不需要太关心他们的区别，比如，我们现在使用的 vue 和 react 实际就抹平了二者的差别，你可以说都是 property。比如 vue 的模板语法中，:attr="object" 加了冒号的属性内容就可以被自动解析。jsx 语法中 attr={js} 也是不再限于字符串。我们后面就不再区分 attribute, property，而是统一使用 attribute 来描述。

   11.   attribute 是组件的配置部分，描述这个组件会如何表现，其中有部分细节需要注意：

   12. 生效时机，仅初始化时生效还是实时生效。
   13. 外部配置与实际配置是否实现为强一致。
   14.   Life cycle：组件代码执行的时机，生命周期通常有, 创建, 挂载, 销毁前等。 vue 和 react 都设计了其生命周期.

   15.   为什么要有生命周期, 因为我们在设计好一个组件以及组件的功能时, 我们需要在一些特定的时候执行一些代码, 比如初始化动作, 获取数据动作等。 我们把做这些动作的时机整理后发现, 我们往往需要在创建的时候需要做一些动作, 在构建好组件的 dom 挂载到页面的时候需要做一些动作, 在销毁前需要做一些动作比如内存释放等。

   16. **什么是好的组件？**

   17.    组件使用人员角度

   18. 组件功能使用，功能不太强大，也不会太小
   19. 好的API文档
   20. 使用简单，易于理解
   21. API不频繁发生break变动
   22.    组件开发人员角度

   23. 组件易于阅读，可清晰了解其能力边界设计
   24. 可扩展功能迭代
   25. 历史债少，已经提供的能力不能轻易删除
   26. **具体可执行操作**

   27.   两种模式：

   28. 看到重复就抽象
   29. 一个页面就是一个组件，一把梭哈就是干
   30.  如何判断是否要拆：

   31. 功能独立，与其他部分的耦合度小
   32. 功能稳定性（UI型的功能一般不稳定）
   33. 功能复用情况，想哪些场景可以用，现在有多少场景可用，未来可能有多少场景可用
   34. 功能复杂度高，复杂度高的组件才有组件化的价值
   35. 感觉能不拆时，先不拆
   36.   组件API设计时的注意点：

   37. 宜精不宜多
   38. 权限能收则收，减少透传设计
   39. 注意属性取名
   40. 不过度设计
   41.   如何提高自己的组件化能力？

   42. 学习前人经验，观察和思考社区组件的设计
   43. 理解业务，理解业务诉求，理解需求的最优价值的点，已经需求的稳定点和变化点
   44. 向后思考，思考未来发展的方向
   45. review 设计，及时调整
   46.  组件化vs模块化

   47.  https://www.cnblogs.com/yichenscc/p/9361856.html

   48.  组件化就是把可以复用的、独立的、基础的、功能专一的代码封装到一个方法或者代码片段里，在未来需要的地方引入使用。用极少的代码实现之前相同的功能，避免了相同功能代码的复写，提高了开发的效率。在未来对该组件功能进行修改的时候只需要修改组件代码就可修改项目里所有的相同功能。组件化属于纵向分块，每个组件就像一个竖直的线永不相交。

   49.  模块化是为了单独实现某一功能模块进行封装的方法，一个模块里可能拥有n个基础组件搭配产生。模块化属于横向分块，每个模块像一条横向把n条竖直的线串联起来形成一个整体。

1. 打包优化
   1.  优化本地开发

   2. 加入Webpack Cache https://webpack.js.org/configuration/cache/
      1.    缓存生成的webpack模块和chunk，来改善构建速度，cache会在开发模式被设置成type:'memory'而且在生产模式中被禁用，

      2. 二次启动时间75s+ -> 2s+, 提高95%+
      3. ```Plain
         cache: devMode
             ? {
                 type: 'filesystem',
                 cacheDirectory: path.resolve(__dirname, '.webpack_cache'),
                 buildDependencies: {
                   config: [path.resolve(__dirname, 'webpack.config.js')],
                 },
               }
             : false,
         ```
   3. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY5ZjNlYTQyMTFhOWJkZjg4MTQ5NmI4MzY1Mzk1NzRfSUJmb0pQRzhQdHo4aVVQeE5KRmdHNTdlM05QMU9oUmdfVG9rZW46Ym94Y25VdGtxZ0Rad3ZGVEljejFYMEtlNE1oXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk1ZTg5M2Y1YzU5Y2JmODE5YTVkZTVhYTczOWFjNGNfeGJuUHc4SzJyY1BSVjhCNmdGeFB1ZEpTRFdOdWwwREZfVG9rZW46Ym94Y254bzFqcFZieG9yZVVSUmFvMThoZmhkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MjE0YjY4YjkwN2IxNzNjODAzYjQ1YTMwYTk4NDZlZTZfT0p3WWNoYWdqbFVWNlU1NFZkeGtLMjJpR2RDbGRzc0ZfVG9rZW46Ym94Y25jSzZ2Y1FQVTNwQ3ROQmJocTNsQUtlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   4. HMR优化 [react-hot-loader](https://github.com/gaearon/react-hot-loader)
      1. React HMR支持，代码更新不触发导航栏级别刷新
      2. ```JavaScript
         // babel.config.json中配置
         {
           "plugins": ["react-hot-loader/babel"]
         }
         const Demo = () => {
             console.log('.....');
             return (
                 <Router>...</Router>
             )
         }
         export default hot(Demo)
         ```
   5. UMD
      1.    `UMD (Universal Module Definition)`，就是一种`javascript`通用模块定义规范，让你的模块能在`javascript`所有运行环境中发挥作用。

      2. [多线程](https://github.com/yuanyuanbyte/Blog/issues/45)提速首次构建 [thread-loader](https://github.com/webpack-contrib/thread-loader) & 缓存提速二次构建 [cache-loader](https://github.com/webpack-contrib/cache-loader)
         1. ​    https://webpack.docschina.org/loaders/thread-loader/#root

         2. ​    https://juejin.cn/post/6844904159670435847

         3. 首次构建时间约18s+, 提速约30%+
         4. 二次构建时间约10s+，提速约 60%+
         5. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTMwNzVlZWE2NDkxM2NiZTk3Zjc5M2Y5ODRhYjMwNjZfazJpZmpYRUpjT2VHT1EwYTIyS0tsRnF3T28zNm5HRkhfVG9rZW46Ym94Y25OMTc1ajJEVnhJV3MwZGdTU0JMeXNmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

         6. ​    cache-loader：在一些性能开销较大的loader之前添加此loader，将结果缓存在磁盘里

         7. ​    https://www.webpackjs.com/loaders/cache-loader/

         8. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNjZDRiN2Q1NzE3YTY3YjhkNzgxOTdjNDU2N2VjYjJfZ09DbFo0TEhNbHJVb3IzbXFLZnFBb05QQWN4ZWNWdThfVG9rZW46Ym94Y25OVERrdjRSMHhjTnBMNXZFYUM5OUJjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 组件库接入starling
   1.  在接入starling的项目中使用npm引入的未接入starling的组件库的时候，我们是扫描不到组件库中的文案的，所以应该在组件库中先完成starling的接入并且暴露出配置语言的属性供项目使用，比如arco-design中的locale。

   2.  需要注意的是将翻译的文案的文件直接保存在项目代码中，所以我们只需要在文案资源文件中添加新增的文案即可

   3. ```JavaScript
      文件所属位置：/src/locale/starling.ts
      import { I18n } from '@ies/starling_intl';
      
      export default (locale, lang = 'zh') =>
        // 创建starling实例 
        I18n.init({
          react: {
            useSuspense: false,
          },
          keySeparator: false,
          // 文案资源，我们选择将翻译文案静态保存在组件库项目中
          resources: {
            [lang]: { translation: locale },
          },
          fallbackLng: ['zh', 'en'],
          lng: lang, // 表示当前语言为【中文】
        });
      
      文件所属位置：/src/locale/interface.ts
      
      export interface Locale {
        [key: string]: string;
      }
      
      文件所属位置：/src/components/ConfigProvider/index.tsx
      
      import starling from '@/locale/starling';
      export interface ConfigProviderProps {
        /** 语言包 */
        locale?: Locale;
        /** 当前语言模式 */
        lang?: 'zh' | 'en';
      }
      /** 组件全局配置Provider */
      const ConfigProvider: React.FC<CommunityConfigProviderProps> = ({ children, ...others }) => {
        const { lang, locale } = others;
        const [I18nReadly, setI18nReadly] = useState(false);
      
        useEffect(() => {
          starling(locale, lang).then(() => setI18nReadly(true));
        }, [lang, locale]);
        // 保证i18n实例初始化完成才渲染页面
        return <ConfigContext.Provider value={contextValue}>{I18nReadly ? children : null}</ConfigContext.Provider>;
      };
      ```

1. 代码规范
   1.  因为我们是在做组件库，每个人的代码风格不一样，所以需要统一代码规范

   2. 提升协作效率
   3. 提升交付质量
   4. 有助于代码审阅
   5. 可降低维护成本
   6. 有利于团队成员养成代码规范的习惯
   7. 在.vscode/extensios.json文件中对于vscode的插件进行配置
   8. 代码缩进：统一使用两个空格，单行140作为代码缩进格式
   9. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YzM1MzEyZmUxYWMwOTJhYmNiOWE4YmZlOTBhNDU1NDVfS3JrQkFGVTJjT01sYlJhZGVXVDg3UGl3cGRMcTU5emVfVG9rZW46Ym94Y25ZZ3dtM0Fsa3BGNzdKekVsa2tEdzVmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   10. 命名
       - 变量函数使用小驼峰camelCase
       - 组件命名，类型定义，类名，枚举，以及枚举值使用PascalCase大驼峰
       - 泛型使用单个大写字母`T`等或`PascalCase`（泛型参数较多易混淆的情况），不使用类型定义前缀（例如`IDemoInterface`、`EEnumDef`等）
       - 常量/配置使用`UPPER_SNAKE_CASE`
       - 文件/文件夹命名使用
         - 组件文件夹命名 `PascalCase`
         - 其它文件夹命名 `kebab-case`
       - 请求中的路径、参数名、参数值使用`camelCase`（如该参数与服务端数据绑定，直接沿用服务端词汇并转换为`camelCase`，不单独取名）
       - 组件导出名称以及组件属性接口名称
         - 组件导出名称与组件文件夹一致
         - 组件属性接口名称 `组件名称+Props`
   11. 将文件代码拆分为不同的区块，各区块间使用空行分割；组件/函数中的代码逻辑同理，将类似的声明/处理逻辑放在一起，不同区块间使用空行隔开，以提升代码清晰度
   12.  文件内容分块规则建议如下：

   13. 三方库依赖引入
   14. 样式文件引入
   15. 自定义组件引入
   16. 杂项引入（类型定义、实用函数等）
   17. 类型定义
   18. 实用函数
   19. 代码主体
   20. 导出相关
   21.  如某块内容过多，可灵活调整，对该块再次进行拆分

   22. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MjQyYjkyODQxOGZlYjVhMDI4OWZiMGZmZTYzOGFiZTJfVVBkZ2hkWGd3NVlLcnRQUnBxYml4R2RtRzBRWE5MZ2dfVG9rZW46Ym94Y25EdThmUmx4NHIwOGVCV29EZE9rZnBkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

# 手撕

## 冒泡排序

```JavaScript
function bubbleSort(arr) {
    const len = arr.length
    for(let i=0; i<len; i++) {
        for(let j=0;j<len-1-i; j++) {
          // 注意边界值
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]] // 交换位置
                // const temp = arr[j+1];
                // arr[j+1] = arr[j];
                // arr[j] = temp;
            }
        }
    }
    return arr
}


console.log(bubbleSort([3,44,15,36,26,27,2,3]))
```

## 快速排序

```JavaScript
function quick(arr){
  if(arr.length<=1) return arr;
  let left =[], right = [];
  let pivotIndex = Math.floor(arr.length/2);
  let pivot = arr.splice(pivotIndex,1)[0];
  for(let i = 0;i<arr.length;i++){
    if(arr[i]>pivot){
      right.push(arr[i])
    }else{
      left.push(arr[i]);
    }
  }
  return quick(left).concat([pivot],quick(right));
}
console.log(quick([3,4,53,21,4,15]))
```

## 插入排序

```JavaScript
// 插入排序
function insert(arr){
  for(let i = 0;i<arr.length;i++){
    const temp = arr[i];
    let j = i;
    while(j>0){
      if(arr[j-1]>temp){
        arr[j] = arr[j-1]
      }else{
        break;
      }
      j -= 1;
    }
    arr[j] = temp;
  }
  return arr
}
```

## 选择排序

```JavaScript
function check(arr){
  for(let i = 0;i<arr.length;i++){
    let indexMin = i;
    for(let j = i;j<arr.length;j++){
      if(arr[j]<arr[indexMin]){
        indexMin = j;
      }
    }
    if(indexMin !== i){
      const temp = arr[i];
      arr[i] = arr[indexMin];
      arr[indexMin] = temp;
    }
  }
  return arr;
}
console.log(check([3,8,21,2,1,3]))
```

## 归并排序

```JavaScript
// 归并排序
function merge(left,right){
  let tem = [];
  while(left.length && right.length){
    if(left[0]<right[0]){
      tem.push(left.shift())
    }else{
      tem.push(right.shift());
    }
  }
  return tem.concat(left,right)
}
function mergeSort(arr){
  const len = arr.length;
  if(len<2) return arr;
  let mid = Math.floor(len/2);
  let left = arr.slice(0,mid);
  let right = arr.slice(mid);
  return merge(mergeSort(left),mergeSort(right))
}
console.log(mergeSort([3,24,3,15,2,6]))
```

## 二分查找

```JavaScript
// 二分查找
function search(arr,target){
  let len = arr.length;
  let left = 0;
  let right = len -1;
  while(left<=right){
    let mid = Math.floor((left+right)/2);
    if(arr[mid]<target){
      left = mid+1;
    }else if(arr[mid]>target){
      right = mid - 1;
    }else{
      return mid;
    }
  }
  return -1;
}
```

## 深浅拷贝

```JavaScript
// 浅拷贝
function clone(origin,target){
  let target = target || {};
  for(let prop in origin){
    target[prop] = origin[prop]
  }
  return target
}
// 深拷贝
// 参考文章 https://juejin.cn/post/6889327058158092302#heading-11
function deepClone(target,cache=new Map()){
  if(cache.get(target)) return cache.get(target);
  if(target instanceof Object){
    let dist;
    if(target instanceof Array){
      dist = [];
    }else if (target instanceof Date){
      dist = new Date(target)
    }else if(target instanceof Function){
      dist = function (){
        return target.call(this,...arguments);
      }
    }else if (target instanceof RegExp){
      // 过正则的source属性就能够拿到正则模式，通过正则的flags属性就能够拿到正则的参数。
      dist  = new RegExp(target.source,target.flags);
    }else{
      dist = {}
    }
    cache.set(target,dist);
    for(let prop in target){
      if(target.hasOwnProperty(prop)){
        dist[prop] = deepClone(target[prop],cache)
      }
    }
    return dist
  }else{
    return target
  }
}
```

## 防抖节流

```JavaScript
// 防抖
function deBounce(fn,delay){
  let timeout  = null;
  return function(){
    clearTimeout(timeout);
    timeout = setTimeout(()=>{
      fn.apply(this,arguments);
    },delay)
  }
}
// 节流
function throttle(fn,delay){
  let canrun = true;
  return function (){
    if(!canrun) return;
    canrun = false;
    setTimeout(()=>{
      fn.apply(this,arguments);
      canrun = true;
    },delay)
  }
}
// requestAnimationFrame节流
function throttle(func){
  let lock = true;
  return function (...args){
    if(!lock) return ;
    lock = false;
    window.requestAnimationFrame(()=>{
      func.apply(this,args);
      lock = true;
    })
  }
}
```

## call，apply，bind的实现

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjMxOWI3ZjZjNGJkNDM3ODM2MTUzZWI2Y2VjMWUzZDdfdXl3SUxzcDhpVEJkazVVTGNZQXc3Y0NIQlo4bG81ZzVfVG9rZW46Ym94Y25hd25TWGxwMkxIZXBmV0FoYWpCUXVkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

```JavaScript
// call
Function.prototype.call = function(context){
  let ctx = context ? context : window;
  // 获取调用call的函数，用this可以获取
  ctx.fn = this;
  const args = Array.from(arguments).slice(1);
  let result = ctx.fn(...args);
  delete ctx.fn;
  return result;
}

// apply
Function.prototype.apply = function (context,args=[]){
  let ctx = context ? context : window;
  ctx.fn = this;
  let result = ctx.fn(...args);
  delete ctx.fn;
  return result; 
}
// bind
Function.prototype.bind = function (context){
    if(typeof this !== 'function'){
        throw new TypeError('not a function');
    }
    // a.bind(b) , 此时this为a
    let self = this;
     // 这里的arguments是使用bind方法时传入的参数列表，即bind方法第一个传参的arguments
    let args = [...arguments].slice(1);
    function Fn(){};
    Fn.prototype = this.prototype;
    let bound = function(){
        let res = [...args,...arguments];
//对三目运算符两种情况的解释： 
//1.当作为构造函数时，this 指向实例
//（注意！！！这里的this是bind返回的新方法里执行时的this，        
//和上面的this不是一个！！！），
//Fn 为绑定函数，因为上面的 `Fn.prototype = this.prototype;`，       
// 已经修改了 Fn.prototype 为 绑定函数的 prototype，此时结果为 true， 
// 当结果为 true 的时候，this 指向实例。 
// 2.当作为普通函数时，this 指向 window，Fn 为绑定函数，此时结果为 false，        
//当结果为 false 的时候，this 指向绑定的 context。 */
        context = this instanceof Fn ? this :context || this;
        return self.apply(context,res);
    }
    bound.prototype = new Fn();
    return bound;
}
```

## New的实现

```JavaScript
// new
// 1. 在内存中创建一个新对象
// 2. 这个新对象内部的[[prototype]]特性被赋值为构造函数的prototype属性 
// 3. 构造函数内部的this被赋值为这个新对象(即this指向新对象)
// 4. 执行构造函数内部的代码(给新对象添加属性)
// 5. 如果构造函数返回空对象，则返回该对象;否则，返回刚创建的新对象
function new(con,...args){
  let obj = {};
  obj.__proto__ = con.prototype;
  let result = con.call(obj,...args);
  return result instanceof object ? result : obj;
}
```

## Instanceof

```JavaScript
function instanceof(targin,origin){
    while(target){
        if(target.__proto__ === origin.prototype){
          return true;
        }
        target = target.__proto__;
    }
    return false;
}
```

## 数组拍平

https://juejin.cn/post/7130658179943235621

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isarray_recursivity

```JavaScript
let flat = arr => {
  return arr.reduce((pre,cur)=>{
    return pre.concat(Array.isArray(cur) ? flat(cur) : cur);
  },[])
}
// 递归
let flat = arr => {
  let res = [];
  for(let i = 0;i<arr.length;i++){
    if(Array.isArray(arr[i])){
      flat(arr[i]);
    }else{
      res.push(arr[i])
    }
  }
}
// flat方法的实现
function flat(array, depth = 1) {
    return depth > 0 ? array.reduce((acc, item) => {
        return acc.concat(Array.isArray(item) ? flat(item, depth - 1) : item)
    }, []) : array.slice()
}
```

## 数组去重

```JavaScript
// 遍历
Array.prototype.unique = function (){
  let temp = {},
      arr = [],
      len = this.length;
  for(let i = 0;i<len;i++){
    if(!temp[this[i]]){
      temp[this[i]] = 'abc';
      arr.push(this[i])
    }
  }
  return arr;
}
// indexof
function unique(arr){
  if (!Array.isArray(array)) {
    console.log('type error');
    return; 
  }
  let res = [];
  let len = this.length;
  for(let i = 0;i<len;i++){
    let cur = arr[i];
    if (res.indexOf(cur) === -1) {
      res.push(cur);
    }
  }
  return res;
}
```

## 函数柯里化

```JavaScript
function curry(fn){
  if(typeof fn !== 'function'){
    throw TypeError('fn is not a function');
  }
  let args = [].slice.call(arguments,1);
  return function(){
    let _args = [].slice.call(arguments);
    return fn.apply(this,args.concat(_args));
  }
}
```

## 手写promise

```JavaScript
class myPromise {
  static PENDING = 'pending';
  static FULFILLED = 'fulfilled';
  static REJECTED = 'rejected';
  constructor(func){
    this.PromiseState = myPromise.PENDING;
    this.PromiseResult = null;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    try{
      func(this.resolve.bind(this),this.reject.bind(this))
    }catch(err){
      this.reject(err)
    }
    
  }
  resolve(result){
    if(this.PromiseState === myPromise.PENDING){
      setTimeout(()=>{
        this.PromiseState = FULFILLED;
        this.PromiseResult = result;
        this.onFulfilledCallbacks.forEach(callback=>{
          callback(result)
        })
      })
      
    }
  }
  reject(reason){
    if(this.PromiseState === myPromise.PENDING){
      setTimeout(()=>{
        this.PromiseState = REJECTED;
        this.PromiseResult = reason;
      })
      this.onRejectedCallbacks.forEach(callback=>{
        callback(reason)
      })
    }
  }
promise.prototype.then
  then(onFulfilled,onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => {  throw reason; };
    const promiseChild = new myPromise((resolve,reject)=>{
      if(this.PromiseState === myPromise.PENDING){
        this.onFulfilledCallbacks.push(()=>{
          try{
            let x = onFulfilled(this.PromiseResult);
            resolvePromise(promiseChild,x,resolve,reject);
          }catch(e){
            reject(e)
          }
        })
        this.onRejectedCallbacks.push(()=>{
          try{
            let x = onRejected(this.PromiseResult);
            resolvePromise(promiseChild,x,resolve,reject);
          }catch(e){
            reject(e)
          }
        })
      }else if(this.PromiseState === myPromise.FULFILLED){
        setTimeout(()=>{
          try{
            let x = onFulfilled(this.PromiseResult);
            resolvePromise(promiseChild,x,resolve,reject);
          }catch (e){
            reject(e)
          }
        })
      }else if(this.PromiseState === myPromise.REJECTED){
        try{
          setTimeout(()=>{
            let x = onRejected(this.PromiseResult);
            resolvePromise(promiseChild,x,resolve,reject);
          })
        }catch(e){
          reject(e)
        } 
      }
    })
    return promiseChild
  }
  promise.prototype.catch
  catch(onRejected){
      return this.then(undefined,onRejected)
  }
  promise.prototype.finally
  // callBack 无论结果是fulfilled或者是rejected，都会执行的回调函数
  finally(callBack){
      return this.then(callBack,callBack)
  }
  promise.prototype.all
  static all(promises){
      return new Promise((resolve,reject)=>{
          if(Array.isArray(promises)){
              let result = [];
              let count = 0;
              if(promises.length === 0){
                  return resolve(promises)
              }
              promise.forEach((item,index) => {
                      myPromise.resolve(item).then(
                          value => {
                              count++;
                              result[index] = value;
                              count === promises.length && resolve(result))
                          }，
                          reason => {
                              reject(reason)
                          }
                      )
              })
          } else {
              return reject(new TypeError('Argument is not iterable')
          } 
      })
  }
  promise.prototype.any
  static any(promises){
      return new Promise((resolve,reject)=>{
          if(Array.isArray(promises)){
              let errors = [];
              let count = 0;
              if(promises.length === 0){
                  return reject(new AggregateError('All promises were rejected')))
              }
              promise.forEach((item,index) => {
                      myPromise.resolve(item).then(
                          value => {
                              resolve(value)
                          }，
                          reason => {
                              count ++;
                              errors.push(reason);
                              count === promises.length && resolve(new AggregateError(errors)))
                          }
                      )
              })
          } else {
              return reject(new TypeError('Argument is not iterable'));
          } 
      })
  }
  promise.prototype.race
  static race(promises){
      return new Promises((resolve,reject)=>{
          if(Array.isArray(promises)){
              if(promises.length > 0){
                  promises.forEach(item => {
                      myPromise.resolve(item).then(resolve,reject);
                  })
              }
          }else{
              return reject(new TypeError('Argument is not iterable'))
          }
      })
  }
  
  promise.prototype.allSettled
  static allSettled(promises){
      return new Promise((resolve,reject)=>{
          if(Array.isArray(promises)){
              let result = [];
              let count = 0;
              if(promises.length === 0){
                  return resolve(promises)
              }
              promises.forEach((item,index)=>{
                  myPromise.resolve(item).then(
                      value => {
                          count++；
                          result[index] = {
                              status: 'fulfilled',                               
                              value
                          }
                          count === promises.length && resolve(result);
                      },
                      reason => {
                          count++；
                          result[index] = {
                               status: 'rejected',
                               reason                          
                          }
                          count === promises.length && resolve(result);
                      }
                  )
              })
          } else {
             return reject(new TypeError('Argument is not iterable')
          }
      })
  }
}
/**
  * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
  * @param  {promise} promiseChild promise1.then方法返回的新的promise对象
  * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
  * @param  {[type]} resolve   promiseChild的resolve方法
  * @param  {[type]} reject    promiseChild的reject方法
*/
function resolvePromise(promiseChild, x, resolve, reject) {
  if (x === promiseChild) {
    return reject(new TypeError('Chaining cycle detected for promise'));
  }
  if (x instanceof myPromise) {
    if (x.PromiseState === myPromise.PENDING) {
      x.then(y => {
        resolvePromise(promise2, y, resolve, reject)
      }, reject);
    } else if (x.PromiseState === myPromise.FULFILLED) {
      resolve(x.PromiseResult);
    } else if (x.PromiseState === myPromise.REJECTED) {
      reject(x.PromiseResult);
    } 
  }else if(x !== null && ((typeof x === 'object' || (typeof x === 'function')))){
    try {
      var then = x.then;
    } catch (e) {
      return reject(e);
    }
    if (typeof then === 'function') {
      let called = false;
      try {
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            resolvePromise(promise2, y, resolve, reject);
          },
          r => {
            if (called) return;
            called = true;
            reject(r);
          }
        )
      } catch (e) {
        if (called) return;
        called = true;
        reject(e);
      }
    } else {
      resolve(x);
    }
  }else{
    return resolve(x);
  }
}
promise.resolve
myPromise.resolve = function(value){
    // 如果这个值是一个 promise ，那么将返回这个 promise     
    if (value instanceof myPromise) {
         return value;
     }else if(value instanceof Object && 'then' in value){
         return new Promise((resolve,reject)=>{
             value.then(resolve.reject);
         })
     }
     // 否则返回的promise将以此值完成，即以此值执行`resolve()`方法 (状态为fulfilled)
     return new myPromise(resolve=>{
         resolve(value)
     })
}
promise.reject
myPromise.reject = function(reason){
    return new Promise((resolve,reject)=>{
        reject(reason)
    })
}
```

## promise封装ajax

```JavaScript
function ajax(method,url,data){
  let xhr = new XMLHttpRequest();
  return new Promise((resolve,reject)=>{
    xhr.onreadystatechange = function (){
      if(xhr.readyState !== 4) return 
      if(xhr.status === 200){
        resolve(xhr.responseText);
      }else{
        reject(xhr.statusText);
      }
    }
    xhr.open(method,url);
    xhr.send(data)
  })
}

ajax('GET', '/api/categories').then(function (data) {
    // AJAX成功，拿到响应数据
    console.log(data);
}).catch(function (status) {
    // AJAX失败，根据响应码判断失败原因
    new Error(status)
});
```

## 手写实现发布订阅者模式

```JavaScript
class Observer {
  constructor(){
    this.message = [];
  }
  $on(type,callback){
    if(!this.message[type]){
      this.message[type] = [];
    }
    this.message[type].push(callback);
  }
  $off(type,callback){
    if(!this.message[type]) return;
    if(!callback){
      this.message[type] = undefined;
    }
    this.message[type] = this.message[type].filter(item=>{
      item !== callback
    })
  }
  $emit(type){
    if(!this.message[type]) return;
    this.message[type].forEach(item=>{
      item();
    })
  }
}
```

## Sleep函数

[JavaScript sleep睡眠函数 - 掘金](https://juejin.cn/post/6920492226594373639)

 js 的延时执行

```JavaScript
// 方案一：使用 while 无限循环占用线程，使用时间戳跳出
function sleep(sleepTime){    // sleepTime为需要锁死的时间
  let now = new Date();
   // 计算得出假死结束时间
  let exitTime = now.getTime() + number(sleepTime);  
  while(true){
    now = new Date();         // 不断获取当前时间
    if(now.getTime() > exitTime){   // 判断当前时间是否大于需要假死的时间
      return;      
    }
  }
}
// 方案二：使用 setTimeout 包裹 promise
const sleep = time => new Promise(resolve => setTimeout(resolve , time))
// 打印将会在一秒后执行
sleep(1000).then(console.log(1))
```

# 算法

## 数组

数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段连续的内存空间

1. 创建数组

```JavaScript
const arr = [1,2,3]
const arr = new Array() 等价于 const arr = []
// 会得到长度为7的数组
const arr = new Array(7)
// 会得到一个长度为7并且每个元素都是1的数组
const arr = (new Array(7)).fill(1) 
```

1. 二维数组

```JavaScript
const arr =(new Array(7)).fill([])
arr[0][0] = 1 // 将一整列的元素都设置为1
```

当给fill传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用

- 初始化二维数组
  - ```JavaScript
    const len = arr.length
    for(let i=0;i<len;i++) {
        // 将数组的每一个坑位初始化为数组
        arr[i] = []
    }
    ```

- 访问二维数组
  - ```JavaScript
    // 缓存外部数组的长度
    const outerLen = arr.length
    for(let i=0;i<outerLen;i++) {
        // 缓存内部数组的长度
        const innerLen = arr[i].length
        for(let j=0;j<innerLen;j++) {
            // 输出数组的值，输出数组的索引
            console.log(arr[i][j],i,j)
        }
    }
    ```

## 栈——只用pop和push完成增删的数组（LIFO，后进先出）

- 栈的实现

- - ```JavaScript
    const stack = [];
    // 入栈
    stack.push(1);
    stack.push(2);
    stack.push(3);
    stack.push(4);
    stack.push(5);
    // 出栈
    while(stack.length){
        const top = stack[stack.length-1]
        console.log('现在出栈的是', top)  
        stack.pop();
    }
    
    打印：
    现在出栈的是 5
    现在出栈的是 4
    现在出栈的是 3
    现在出栈的是 2
    现在出栈的是 1
    ```

## 队列——只用 push 和 shift 完成增删的“数组”（FIFO，先进先出）

队列的实现

```JavaScript
const queue = []  
queue.push(1)
queue.push(2)
queue.push(3)  
  
while(queue.length) {
    // 单纯访问队头元素（不出队）
    const top = queue[0]
    console.log(top,'出队元素')
    // 将队头元素出队
    queue.shift()
}
打印：
1 出队元素
2 出队元素
3 出队元素
```

## 链表

1. 链表中的结点，则允许散落在内存空间的各个角落里。在内存中的形态可以是散乱如下的。

1. 在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：
   1. ```JavaScript
      {
          // 数据域
          val: 1,
          // 指针域，指向下一个结点
          next: {
              val:2,
              next: ...
          }
      }   
      ```

1. 链表的基本形态

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OTg3OGU3ZDQyOTBkZjdiMmQwNDQ3MWY4ZWFkN2FhNjBfRERoYTZrdGVmZm5Xa0pUaks5R3J6VDhlV1Ixd0pzVXJfVG9rZW46Ym94Y25NbDZpQXNrRENXM2E4OXV6QzFiUDdnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 链表节点的创建

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFjMjY4NmVmODVjYTliZDBmODI1NDEwYjU4MGQzZDhfRmFHQXhtR2NUU0hNU3JPdFFXOXZWY0NoRklMckdHU1pfVG9rZW46Ym94Y25sUDNFM2ZDWk1pRXo5UlFVOFlZSVliXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 链表元素的添加
   1. ```JavaScript
      // 如果目标结点本来不存在，那么记得手动创建
      const node3 = new ListNode(3)     
      // 把node3的 next 指针指向 node2（即 node1.next）
      node3.next = node1.next
      // 把node1的 next 指针指向 node3
      node1.next = node3
      ```

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFiMDk2MzA0ZTFhNmUwMmM1ZjRjMzljNDEwY2UzOTRfR2s4MEI4WE5qejZTUm55RFVSRExHYnJXb1RIbDJsV1lfVG9rZW46Ym94Y25jTXhlSW5YcW1vWVQyQVk2b3NhTFpjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 链表元素的删除

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDJkZTY4YzYwZDAxODMwMTUxYTI3YTdkOWM3ZWU5N2NfUzZ1SGF1ZGdEbnJIZkRMVjN3VXZnTEZLdTJoWW4xOFhfVG9rZW46Ym94Y253Z0JPRlB5UjBHQUtjRHVheU05bkNkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

```JavaScript
node1.next = node3.next 
```

在涉及链表删除操作的题目中，重点不是定位目标节点，而是定位目标节点的前驱节点

## 链表&数组辨析

**我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)**。

在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

## 树

1. 二叉树的编码实现

```JavaScript
// 二叉树结点的构造函数
function TreeNode(val){
    this.val = val;
    this.left = this.right = null;
}
// 新建一个二叉树节点
const node = new TreeNode(1)
```

1. 递归遍历（前中后序遍历）——中间节点位置
   1. ```JavaScript
      // 根节点
      const root = {
        val: "A",
        left: {
          val: "B",
          left: {
            val: "D"
          },
          right: {
            val: "E"
          }
        },
        right: {
          val: "C",
          right: {
            val: "F"
          }
        }
      };
      ```

   2. 前序遍历——中左右
   3. ```JavaScript
      function preorder(root){
          if(!root){
              return 
          }
          console.log(root.val)
          preorder(root.left)
          preorder(root.right)
      }
      ```

   4. 中序遍历——左中右
   5. ```JavaScript
      function midorder(root){
          if(!root){
              return 
          }
          midorder(root.left);
          console.log(root.val)
          midorder(root.right);
      }
      ```

   6. 后序遍历——左右中
   7. ```JavaScript
      function backorder(root){
          if(!root){
              return 
          }
          backorder(root.left)
          backorder(root.right)
          console.log(root.val)
      }
      ```

1. 迭代遍历

## 回溯算法

基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路试试

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MDI4Yjc1NDQyZmU2NTk0NzQ4YzFhNTliZThjN2MwZWNfeWpnSnBSV254REVockxKd1VMY1FHQmFqbUE4NTkxYjNfVG9rZW46Ym94Y25lZzNoaXV2T3UyTnNwb0xaRHkxbGJiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

# Html&css

1. white-space：如何处理元素中的空白
   1. normal：连续的空白会被合并，换行符会被当作空白符来处理，换行在填充行框盒子时是必要
   2. nowrap：和normal一样，连续的空白符会被合并，但文本内的换行无效
   3. pre：连续的空白符会被保留，再遇到换行符或者<br>元素时才会换行
   4. pre-wrap：连续的空白符会被保留，再遇到换行符或者<br>元素，或者需要为了填充行框盒子时才会换行
   5. pre-line：连续的空白符会被合并，再遇到换行符或者<br>元素，或者需要为了填充行框盒子时才会换行
   6. break-spaces：与pre-wrap行为相同，除了：
      - 任何保留的空白序列总是占用空间，包括在行尾
      - 每个保留的空格字符后都存在换行机会，包括空格字符之间。
      - 这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。
   7. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=M2FmMGY1MjBlZTEyMmMwNmJhM2M2ZjcyODdmMDRlNzhfNnk5STNZYlFmeksxN3gyYjZBczZwTUlFV2s4STNOQ2FfVG9rZW46Ym94Y25DTzZVRmVJWUEySWEzUDRiWTB2RUxqXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## doctype

HTML 4.01中的doctype需要对 DID进行引用，因为Html 4.01基于sgml

 html5不基于sgml，因此不需要对did进行引用，但是需要doctype来规范浏览器的行为

## css性能优化

- 内联首屏重要css

- 异步加载css
  -  在CSS文件请求、下载、解析完成之前，CSS会阻塞渲染，浏览器将不会渲染任何已处理的内容

  -  前面加载内联代码后，后面的外部引用css则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，比如下面的方案

- 资源压缩

- 去除无用的css，文件通常只会去除无用的空格，我们还可以手动删除代码中无用的css

- 合理使用选择器
  - 通配符和属性选择效率最低，避免使用
  - 使用Id选择器就没有必要再嵌套
  - 不要嵌套使用过多复杂选择器，最好不要三层以上

- 减少使用昂贵的属性
  -  在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能

- 减少重排与重绘

- 不要使用@import

## Flex：1

flex：1等价于flex：1 1 0；

flex-grow：这个属性规定了 `flex-grow` 项在 flex 容器中分配剩余空间的相对比例。

flex-shrink： 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。

flex-basis：属性 `flex-basis` 指定了 flex 元素在主轴方向上的初始大小

## [margin塌陷：](https://www.jianshu.com/p/85590424958c)

在垂直方向如果有两个元素的外边距有相遇，在浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值比较大的，边距小的塌陷到了边距值大的值内部

1. 同级元素塌陷：上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正盒子之间是距离较大的那个值

1. 父子元素塌陷：
   1. 父元素和子元素都设置了同方向的margin-top值，两个属性之间没有其他内容进行隔离，导致两个属性相遇，发生margin塌陷
   2. 本身父元素与上一个元素的距离是0.子元素如果设置了垂直方向的上边距，会带着父元素一起掉下来

1. 解决方法：
   1. 同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。
   2. 父子元素：让两个边距不要相遇，中间可以使用父元素border或padding将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用子元素的margin去设置，而是用父元素的padding挤出来。

## 监听动画

监听animationEnd事件可以在css动画完成之后触发

## Calc

此css函数允许在声明css属性值时执行一些计算

## [post-css](https://juejin.cn/post/7062717813764390948)

是一种js工具，可将你的css代码转换为抽象语法树AST，然后提供API用于使用js插件对其进行分析和修改。可以理解为css的babel工具

## css单位

[作为前端，你应该了解的分辨率/逻辑像素/物理像素/retina屏知识🧐 - 掘金](https://juejin.cn/post/6918323869824909319)

1. px
   1.  逻辑像素/web像素/css像素

   2.  是一个绝对单位，是一个固定的值，反映了真实的物理尺寸，电脑屏幕分辨率是1920*1200，那么对应的像素值是1920px*1200px

   3. ###  移动端1px问题

   4.  说成1px不如说成1物理像素

   5.  像素 ：指在由一个数字序列表示的图像中的一个最小单元，单位是 px，不可再次分割了。 设备像素比（DPR）: 设备像素比 = 设备像素 / 设备独立像素。

   6.  当逻辑像素（设备独立像素）为1px时，在DPR为2的设备上显示为2px的物理像素（设备像素）

   7.  解决方案：

   8. 利用css中的transform: scaleY(0.5)
   9. 媒体查询根据不同DPR缩放

1. em和rem
   1.  1em = font-size的属性值。em 是相对于父元素的字体大小进行计算的

   2.  rem是根据页面根元素的字体大小来计算的，font-size: 1rem的作用与font-size: initial相同

## flex和block的区别

block是所有元素都占一行，flex是包裹在一起的元素占一行

## Align-content

设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的株洲在内容项之间和周围分配空间

# Js

[一篇文章解决Promise...then，async/await执行顺序类型题 - 掘金](https://juejin.cn/post/6973817105728667678)

## requestAnimationFrame

`window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配

## super

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM0OTc3NWJkN2E2ZWMxODdiOWIxZDY5ZTg2NmVkMzhfNHZTRnlpRE1Ic3pLSE9ONEdHTTc5dGVXUk9paFFIeExfVG9rZW46Ym94Y245OE5FcG5NclFHek54M0gwWmkxcUxkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## CSR&SSR

### 一、SSR是什么？

要想搞清楚 SSR 是什么？需要先理解这个方案是为解决什么问题而产生的。

无论是 Vue 还是 React 的全家桶，都有路由框架的身影，所以，页面的渲染流程也全部都是浏览器加载完 JavaScript 文件后，由 JavaScript 获取当前的路由地址，再决定渲染哪个页面。

这种架构下，所有的路由和页面都是在客户端进行解析和渲染的，我们称之为 Client Side Rendering，简写为 CSR，也就是客户端渲染。

交互体验确实提升了，但同时也带来了两个小问题。

首先，如果采用 CSR，在vue-cli搭建的项目中执行npm run build命令后，可以在项目根目录下看到多了一个 dist 文件夹，打开其中的 index.html 文件，看到下面的代码：

```HTML
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="/favicon.ico" />
    <title>ssr-demo</title>
    <link href="/css/app.fb0c6e1c.css" rel="preload" as="style" />
    <link href="/js/app.891eb5a3.js" rel="preload" as="script" />
    <link href="/js/chunk-vendors.1625926f.js" rel="preload" as="script" />
    <link href="/css/app.fb0c6e1c.css" rel="stylesheet" />
  </head>
  <body>
    <noscript
      ><strong
        >We're sorry but ssr-demo doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      ></noscript
    >
    <div id="app"></div>
    <script src="/js/chunk-vendors.1625926f.js"></script>
    <script src="/js/app.891eb5a3.js"></script>
  </body>
</html>Ï
```

这就是项目部署上线之后的入口文件，body 内部就是一个空的 div 标签，用户访问这个页面后，页面的首屏需要等待 JavaScript 加载和执行完毕才能看到，这样白屏时间肯定比 body 内部写页面标签的要长一些，尤其在客户端网络环境差的情况下，等待 JavaScript 下载和执行的白屏时间是很伤害用户体验的。

其次，搜索引擎的爬虫抓取到你的页面数据后，发现 body 是空的，也会认为你这个页面是空的，这对于 SEO 是很不利的。即使现在基于 Google 的搜索引擎爬虫已经能够支持 JavaScript 的执行，但是爬虫不会等待页面的网络数据请求，何况国内主要的搜索引擎还是百度。

像掘金对白屏时间和搜索引擎有要求，我们就需要在用户访问页面的时候，能够把首屏渲染的 HTML 内容写入到 body 内部，也就是说我们需要在服务器端实现组件的渲染，这时候就需要使用ssr。

### 二、怎么做SSR

在Vue中有提供 @vue/server-renderer 这个专门做服务端解析的库。

创建一个新的文件夹 vue-ssr，安装一下 server-renderer、vue 和 express。

然后新建 server.js，核心就是要实现在服务器端解析 Vue 的组件，直接把渲染结果返回给浏览器。

通过express 启动了一个服务器，监听 9093 端口；在用户访问首页的时候，通过createSSRApp 创建一个 Vue 的实例，并且通过 @vue/compiler-ssr 对模板的 template 进行编译，返回的函数配置在 vueapp 的 ssrRender 属性上，最后通过 @vue/server-renderer 的 renderToString 方法渲染 Vue 的实例，把 renderToString 返回的字符串通过 res.send 返回给客户端。

```JavaScript
// 引入express
const express = require('express') 
const app = express()
const Vue = require('vue') // vue@next
const renderer3 = require('@vue/server-renderer')
const vue3Compile= require('@vue/compiler-ssr')

// 一个vue的组件
const vueapp = {
  template: `<div>
    <h1 @click="add">{{num}}</h1>
    <ul >
      <li v-for="(todo,n) in todos" >{{n+1}}--{{todo}}</li>
    </ul>
  </div>`,
  data(){
    return {
      num:1,
      todos:['吃饭','睡觉','学习Vue']
    }
  },
  methods:{
    add(){
      this.num++
    }
  } 
}
// 使用@vue/compiler-ssr解析template
vueapp.ssrRender = new Function('require',vue3Compile.compile(vueapp.template).code)(require)
// 路由首页返回结果
app.get('/',async function(req,res){
    let vapp = Vue.createSSRApp(vueapp)
    let html = await renderer3.renderToString(vapp)
    const title = "Vue SSR"
    let ret = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${title}</title>
  </head>
  <body>
    <div id="app">
      ${html}
    </div>
  </body>
</html>`    
    res.send(ret)
})

app.listen(9093,()=>{
    console.log('listen 9093')
}) 
```

访问页面查看源代码就能看到下图效果：

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MzIwZDExZjQ0M2M3ZTUxMmIyNjZiMWU2NjRhMTYwZDdfSXM1d1V6TWJxekxXcEx4M2NwV1BPTlJWUFU4YUExMURfVG9rZW46Ym94Y25kV0VhY2N5OGJRZTlMR3dMRmpORU9oXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### 三、SSR的优缺点 [服务端渲染指南 | Vue.js](https://v3.cn.vuejs.org/guide/ssr/introduction.html#什么是服务端渲染-ssr)

优点：

- 更好的搜索引擎优化 (SEO)。因为搜索引擎爬虫会直接读取完整的渲染出来的页面。

- 注意，目前 Google 和 Bing 已经可以很好地为同步加载的 JavaScript 应用建立索引。在这里同步加载是关键。如果应用起始状态只是一个加载中的效果，而通过 API 调用获取内容，则爬虫不会等待页面加载完成。这意味着如果你的页面有异步加载的内容且 SEO 很重要，那么你可能需要 SSR。

- 更快的内容呈现，尤其是网络连接缓慢或设备运行速度缓慢的时候。服务端标记不需要等待所有的 JavaScript 都被下载并执行之后才显示，所以用户可以更快看到完整的渲染好的内容。这通常会带来更好的用户体验，同时对于内容呈现时间和转化率呈正相关的应用来说尤为关键。

缺点：

- 开发一致性。浏览器特有的代码只能在特定的生命周期钩子中使用；一些外部的库在服务端渲染应用中可能需要经过特殊处理。

- 需要更多的构建设定和部署要求。不同于一个完全静态的 SPA 可以部署在任意的静态文件服务器，服务端渲染应用需要一个能够运行 Node.js 服务器的环境。

- 更多的服务端负载。在 Node.js 中渲染一个完整的应用会比仅供应静态文件产生更密集的 CPU 运算。所以如果流量很高，请务必准备好与其负载相对应的服务器并采取明智的缓存策略。

### 四、vue中编写ssr的代码约束 [编写通用的代码 | Vue.js](https://v3.cn.vuejs.org/guide/ssr/universal.html#服务端的数据响应性)

1. 服务端的数据响应性

在仅针对客户端的应用中，每个用户都在各自的浏览器中使用一个干净的应用实例。对于服务端渲染来说我们也希望如此：每个请求应该拥有一个干净的、相互隔离的应用实例，以避免跨请求的状态污染。

因为实际的渲染过程需要确定性，我们也会从服务器“预获取”数据——这意味着应用状态在我们开始渲染之前已经被解析好了。这也意味着数据响应性在服务端不是必要的，因此它默认是不开启的。禁用数据响应性也避免了将数据转换为响应式对象的性能损耗。

1. 组件生命周期钩子

因为这里没有动态更新，唯一会在 SSR 过程中被调用的[生命周期钩子](https://v3.cn.vuejs.org/guide/instance.html#生命周期钩子)是 `beforeCreate` 和 `created`。这意味着其它生命周期钩子 (如 `beforeMount` 或 `mounted`) 中的任何代码将只会在客户端执行。

另一个值得注意的是你应该避免代码在 `beforeCreate` 或 `created` 中产生全局的副作用，例如通过 `setInterval` 设置定时器。在仅针对客户端的代码中，我们可以设置定时器，然后在 `beforeUnmount` 或 `unmounted` 时撤掉。然而，因为销毁相关的钩子在 SSR 过程中不会被调用，这些定时器就会永久地保留下来。为了避免这种情况，请把副作用代码移至 `beforeMount` 或 `mounted` 以代之。

1. 访问特定平台的 API

通用的代码不能假设能够访问特定平台的 API，因此，如果你的代码直接使用了只存在于浏览器中的全局变量，例如 `window` 或 `document`，它们在 Node.js 中执行的时候将抛出错误。反之亦然。

对共享于服务端和客户端之间但使用不同平台 API 的任务来说，我们推荐把这些特定平台的实现包裹在一个通用的 API 里，或使用现有的库来替你做这件事。例如 [axios](https://github.com/axios/axios) 是一个在服务端和客户端暴露相同 API 的 HTTP 客户端。

对于只存在于浏览器中的 API 来说，通常的建议是晚些时候在针对客户端的生命周期钩子中访问。

注意：如果一个第三方库在编写的时候没有考虑通用的用法，那么要将它集成到服务端渲染应用中可能会比较棘手。你*可以*通过仿造一些全局变量让其工作起来，但是这种做法带有侵入性，且可能会妨碍到其它库的环境监测代码。

1. 自定义指令

大多数[自定义指令](https://v3.cn.vuejs.org/guide/custom-directive.html#自定义指令)都会直接操作 DOM，这会导致 SSR 过程发生错误。所以我们推荐使用组件这种抽象机制替代指令。

### 五、同构渲染

所谓同构就是采用一套代码，构建双端（server 和 client）逻辑，最大限度的重用代码，不用维护两套代码。而传统的服务端渲染是无法做到的，react 的出现打破了这个瓶颈，并且现在已经得到了比较广泛的应用。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NTgxZDJhMjUwMTIzNWZiZGI5NWUxNThkMGExMjQzMDRfS3liQ2F1YUZIdlRFc3lTZnU5Q2toUWVpU3VwWExRdDdfVG9rZW46Ym94Y240ZHhMeDdVTnJRc21MT0xtT2I0MGVlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 路由同构

在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。

1. 数据同构

客户端渲染的时候一般先显示组件再根据异步数据去render，而在服务端组件内容确定就不会再次渲染了；

1. 打包差异

服务端不需要css等

1. 渲染同构

只有当服务端和浏览器端渲染的组件具有相同的`props` 和 DOM 结构的时候，组件才能只渲染一次。当双端节点对比失败，导致组件重新渲染，从而导致浏览器端的 js 执行完成后，发现数据重新请求了，组件的重新渲染导致页面看上去有些闪烁。

处理：hydrate

- 数据注水：

在服务端将预取的数据注入到浏览器，使浏览器端可以访问到，客户端进行渲染前将数据传入对应的组件即可。

- 数据脱水：

在客户端组件渲染前先拿到数据，并且传入组件就可以了。

[React 中同构（SSR）原理脉络梳理](https://segmentfault.com/a/1190000016722457)

[一文吃透 React SSR 服务端渲染和同构原理](https://segmentfault.com/a/1190000020417285)

## Class

https://juejin.cn/post/7021069095336411166

## For...of,for...in,forEach,map的区别

- for...in：forin循环只能获得键名，不能获取键值，为遍历对象设计，目的是枚举对象属性，该语句在原型链中上升，会枚举继承的属性

- for...of：允许遍历获得键值，可以与break，continue，return使用，不能遍历对象

## Esmodule，commonjs，UMD，AMD

https://juejin.cn/post/6935973925004247077

## Npm run dev的时候发生了什么

https://blog.csdn.net/web2022050901/article/details/125165316

https://www.jianshu.com/p/09717b23dca7

## setTimeout()倒计时为什么会出现误差

setTimeout()只是将事件插入了任务队列，必须等当前代码（执行栈）执行完，主线程才会去执行他指定的回调函数，要是当前代码消耗时间很长，也有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout()指定的时间执行，所以setTimeout（）的第二个参数表示的是最少时间，并非是确切是时间

HTML5标准规定了 `setTimeout()` 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前。老版本的浏览器都将最短时间设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常是间隔16毫秒执行。这时使用 `requestAnimationFrame()` 的效果要好于 `setTimeout()`

## Fetch

https://github.com/yuanyuanbyte/Blog/issues/105

fetch()是xmlHttpRequest的升级版，用于在js里面发出http请求

```JavaScript
// 基本使用
fetch(url，options).then(response => response.json()) //解析为可读数据
 .then(data => console.log(data))//执行结果是 resolve就调用then方法
 .catch(err => console.log("Oh, error", err))//执行结果是 reject就调用catch方法
```

fetch(url,options):

- 第一个参数：请求的url

- 第二个参数：定制http请求
  - 请求方法
  - 提交的json数据
  - 请求头
  - ```JavaScript
    const response = await fetch(url, {
        method: 'POST',
        headers: {
            "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        },
        body: 'foo=bar&lorem=ipsum',
    });
    const json = await response.json();
    ```

优点：

- 语法简介，语义化，业务逻辑更清晰

- 基于标准promise实现，支持async/await

- 通过数据流处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求打问奶奶或者网速慢的场景相当有用，xmlhttpRequest对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来

Api：

- Response.json()：`Response` 的 `json()` 方法接收一个 `Response` 流，并将其读取完成。它返回一个 Promise，Promise 的解析 resolve 结果是将文本体解析为 JSON。

- response.ok：该属性返回一个布尔值，表示请求是否成功，表明响应是否成功

- response.status：返回响应的状态代码。**只有通过response.status才能得到http回应的真实状态吗，才能判断请求是否成功**

- response.statusText：属性返回与状态代码相对应的状态消息（例如请求成功以后，服务器返回"OK"）。

- response.url：该属性返回请求的url，如果url存在跳转，该属性返回的是最终url

- response.type：返回请求的类型
  - basic：普通请求，即同源请求
  - cors：跨域请求
  - error：网络错误
  - opaque：如果fetch()请求的type属性设为no-cors，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似表单的那种跨域请求。
  - opaqueredirect：如果fetch()请求的redirect属性设为manual，就会返回这个值，详见请求部分。

## 手写实现发布订阅者模式

实现思路：

- 创建一个class类

- 在这个类里创建一个缓存列表（调度中心）

- on方法，用来把函数fn添加到缓存列表（订阅者注册事件到调度中心）

- emit方法，取到event事件类型，根据event值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）

- off方法，可以根据event事件类型取消订阅

```JavaScript
class Observer {
  constructor(){
    this.message = [];
  }
  $on(type,callback){
    if(!this.message[type]){
      this.message[type] = [];
    }
    this.message[type].push(callback);
  }
  $off(type,callback){
    if(!this.message[type]) return;
    if(!callback){
      this.message[type] = undefined;
    }
    this.message[type] = this.message[type].filter(item=>{
      item !== callback
    })
  }
  $emit(type){
    if(!this.message[type]) return;
    this.message[type].forEach(item=>{
      item();
    })
  }
}
```

## [Cdn（内容分发网络）](https://juejin.cn/post/7008708776119894029)

CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的**边缘服务器**，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，**提高用户访问响应速度和命中率。**

优点：

- js体积变小，使用CDN的第三方资源的js代码，将不再打包到本地服务的js包中，减小本地js包的体积，提高加载速度

- 给网页加载提速

## 一些方法

### **Object.defineProperty()**

Object.defineProperty(obj, prop, descriptor)

### Reduce

该方法作为一个累加器，数组中的每个值从左到右开始缩减，最终计算为一个值，对于空数组是不会执行回调函数的

reduce里面一定要有return，return的值将作为下一次的pre值

### [Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)——浅拷贝

该方法将所有[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable)（`Object.propertyIsEnumerable()` 返回 true）和[自有](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)（`Object.hasOwnProperty()` 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。

### Object.observe()

该方法用于异步的监视一个对象的修改，当对象属性被修改时，方法的回调函数会提供一个有序的修改流，但是这个接口目前已经被废弃，可以使用proxy替代

### window.requestAnimationFrame()

高速浏览器我希望执行一个动画，ing且要求浏览器在下次重回之前调用指定的回调函数更新动画，该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

### RegExp.prototype.source

`source` 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTIzYWU1NWRjNjc4ZWI1MDM0MWE5MGQzMGNiM2E0ODJfS21CYU5mUmdSc1lvQ093b0MyeUVWZHB3RE8xRHRJQUNfVG9rZW46Ym94Y254SnI3cWlQVmdYczRDYTM1NTcydXBoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### RegExp.prototype.flags

属性返回一个字符串，由当前正则表达式对象的标志组成。

clientHeight：浏览器视口的高度

scrollTop：滚动轴滚动的距离

offsetTop：图片的头部距离浏览器顶部的高度

## [Object.freeze()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)

该方法可以冻结一个对象，一个被冻结的对象再也不能被修改，冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举型，可配置性，可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改

## bind

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDMwZWY1Y2JhMWVjZjY5M2U1YjM1ZDI1MzNhMTNlZjhfRDVYdFFBVk84VEE3eGNLeE9uQzlaODBpOFBFVzA1QzNfVG9rZW46Ym94Y25oVGNQb1k5bnJxVGZUVmZPc2l2d3plXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

```JavaScript
Function.prototype.bind = function (context){
    if(typeof this !== 'function'){
        throw new TypeError('not a function');
    }
    // a.bind(b) , 此时this为a
    let self = this;
    let args = [...arguments].slice(1);
    function Fn(){};
    Fn.prototype = this.prototype;
    let bound = function(){
        let res = [...args,...arguments];
        context = this instanceof Fn ? this :context || this;
        return self.apply(context,res);
    }
    bound.prototype = new Fn();
    return bound;
}
```

## this指向

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkxYjc5MDdlZGZhOGM1M2Y1Mzc0NzNmYzZkZWZiMjdfZ3BsUXNONjJMeXdZSmNjN1JJRGlHaFJBVks4Z1FqWEJfVG9rZW46Ym94Y25wOGw4c2pDTjhJV2t0cWxWbGh5eE1iXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVlZTMxODI4M2RhNjA0NDgzNTFiZDQxNDdhNTNlY2Vfb2UxdldjMnVpa0kxWWU3QzNuVnA5aGlSNG9ZRmdGRFVfVG9rZW46Ym94Y242TXJBMEs5WDcxTGdjQWg2V3dwUzhiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 执行上下文和作用域链

执行上下文就是当前js代码呗解析和执行时所在环境，js执行上下文栈可以认为是一个存储函数调用的栈结构

当一段js代码在运行的时候，它实际上是运行在执行上下文中

- js执行在单线程上，所有的代码都是排队执行

- 浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部

- 每个函数会在执行的时候创建自己的执行上下文，并且把它压入执行栈的顶部，这个上下文就是通常说的本地上下文，当前函数执行完毕并退出的时候，其上下文也从栈中弹出并销毁

- 主程序退出，全局执行上下文从执行栈中弹出，此时战中所有的上下文都已经弹出，程序执行完毕

作用域链：函数执行所需要的变量在当前作用域中找不到的时候，就会一层一层向上查找，一直找到全局作用域，这种一层一层的关系就是作用域链

定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

## cookie如何解决无状态的问题

我们将一个用户一次对服务的访问称为会话，服务器在第一次接收到这个会话时，生成一个sessionID存储在服务器，然后通过http的set-cookie字段告诉浏览器把这个sessionID存储到浏览器，然后下次再发起请求的时候，将浏览器cookie中存储的sessionID通过cookie这个字段传给服务，服务可通过http请求带过来的sessionID在服务器中匹配是否有对应的sessionID，从而知道发起这个请求的用户是谁

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM2NmIxYmQwYmExYTA4Y2RkOGRiMDEyZGIwZDhmYTBfQzlqZEVOSUQ5OE9HM3BLVmhmQzl3bjBsdmtRRUZ5a2RfVG9rZW46Ym94Y25RRmg5SUV1ZFJLRDRXQzBmdEd6aXBlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## Token

token时访问资源接口时所需要的资源凭证

简单token的组成：

- uid（用户唯一的身份凭证）

- time（当前时间的时间戳）

- sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）

特点：

- 服务端无状态化，可扩展性好

- 支持移动端设备

- 安全

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OTZlZDU2NTM4Mjc4NzA0Y2JjODAwMjRjNGNjNmM5MzFfb2FRVG12QnlnNWgzVms3UERxVHFVSzFUbk9QOTNDdUhfVG9rZW46Ym94Y25TbVVsVXVlSGhYTkQ0b1B0VDZKemcxXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## [Jwt——json web token](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

目前最流行的跨域认证解决方案，是一种认证授权机制

## encodeUri和encodeUriComponent

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNlZGQyMzY3OWNjOTdmYWU2YmJiN2MyZjEwYWMxMTlfVEptN3k1MEdMb0NQajhtRWZxWjY2dHoySWducHlQZWhfVG9rZW46Ym94Y25LTTZBYUE3dGlwZmZ0OURJd0VXdHNjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## Restful

[RESTful API 一种流行的 API 设计风格](https://restfulapi.cn/)

[什么是REST | RESTful API 中文网](http://restful.p2hp.com/)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY3MWYyZTEzM2NjNDIxNDBkNzdlNDljYjc3ZGEzYzBfWWVEWG1lanBBOUVLSk53cUg5clJsRG1ac3E5SVVUenJfVG9rZW46Ym94Y253enltd3NEeGg5aE9wNjl5ZHNoV3BjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## **[自定义事件](https://juejin.cn/post/6990156087726964766)**

两种方法区别：

CustomEvent可以传递数据

1. Event()
   1. ```JavaScript
      const myEvent = new Event(eventName,eventOptions);
      eventname:String类型，必选项，表示事件的名称
      eventOptions：Object类型，事件的可选配置项
      - bubbles ：事件是否冒泡
      - cancelable : 事件是否能被取消
      
      const sendEvent = new Event("sendMsg")
      document.addEventListener("sendMsg",print)
      document.dispatchEvent(sendEvent)
      function print() {
        console.log("内容色情低俗")
      }
      // result：内容色情低俗。
      ```

1. CustomEvent()
   1. ```JavaScript
      const myEvent = new CustomEvent(eventName, eventOptions);
      eventname:String类型，必选项，表示事件的名称
      eventOptions：Object类型，事件的可选配置项
      - detail: 事件中需要被传递的参数
      - bubbles：事件是否冒泡
      - cancelable：事件是否能被取消
      
      const sendEvent = new CustomEvent("sendMsg", {detail:{
        name: "mayoha"
      }})
      document.addEventListener("sendMsg",print)
      document.dispatchEvent(sendEvent)
      function print(e) {
        console.log(e.detail.name)
      }
      ```

## async/await的错误怎么捕获

- try...catch
  - ```JavaScript
    import api from './api.js' // 引入了一个请求库
    
    run();
    
    async function run() {
            const res = await axios.get('xxxx')  
      // 期待打印出请求结果，但因为没有做错误处理，
      // 导致当网络请求出错时，这一行既没有走到，
      // 控制台也没有抛出 Error，会很难定位问题
      console.log(res)
    }
    try代码块中被return的rejected的epromise时无法被捕获的
    run();
    
    async function run() {
      try {
        // 注意： 这是一个 `return` ，不是 `await`
        return Promise.reject(new Error('Oops!'));
      } catch (error) {
        // 不会运行
      }
    }
    ```

## GUI 渲染线程和 JS 引擎线程是相互排斥的，比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。

## 性能优化

[应用性能前端监控，字节跳动这些年经验都在这了 - 掘金](https://juejin.cn/post/7010647775880708133)

## [Websocket](https://cloud.tencent.com/developer/article/1887095)

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGY3MmY0ZTAzNTYwNTRjYTViYjAzMTQzZGU3MGM4YjZfME5Ud1B6WkxjeHR6RmwxYUJEUXhYVUtZNnBtSGVsSUZfVG9rZW46Ym94Y25hZWdacENTN3RiRGN6ZEFqT2VUOVZoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

wss表示使用了TLS的websocket

轮询：由浏览器每隔一段时间向服务器发出http请求，然后服务器返回最新的数据给客户端

## cookie失效

1. 如果cookie设置了expires属性，则cookie的生命周期只是在当前的会话中，关闭浏览器意味着这次会话的结束，此时cookie失效

1. 浏览器关闭的时候

## Web worker

[聊聊 webworker - 掘金](https://juejin.cn/post/6844903478091841549)

[MessageChannel - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel)

## [Array.sort()的原理](https://zhuanlan.zhihu.com/p/55338902)

V8引擎：在数组长度小于等于10的用插入排序，比10大的数组使用快速排序

Mozilla、Firefox：归并排序

Webkit：底层实现使用了C++库中的qsort（）方法

每项调用String()方法，可以接受一个比较函数

- 函数返回值为负值时，a在b之前，升序

- 等于0的时候，a和b的相对位置不变

- 大于0的时候，b在a前面

# ts

暂时无法在飞书文档外展示此内容

1. ts为什么会火爆？
   1. 如果我们对某种类型只做该类型允许的操作，就叫做类型安全
      1. **不同类型变量占据的内存大小不同**：boolean 类型的变量会分配 4 个字节的内存，而 number 类型的变量则会分配 8 个字节的内存，给变量声明了不同的类型就代表了会占据不同的内存空间。
      2. **不同类型变量可做的操作不同**：number 类型可以做加减乘除等运算，boolean 就不可以，复合类型中不同类型的对象可用的方法不同
   2. 类型检查
      1. 动态类型检查：在运行时做。**适合简单的场景**
         1. 优点：代码写起来较为简单
         2. 缺点：源码中不保留类型信息，对某个变量赋什么值、做什么操作都是允许的，但是比如对string做了乘除的操作，这样的错误只有在运行时才会被检查出来
      2. 静态类型检查：运行之前的编译时做。**增加写代码的成本，但是能更好的保证代码的健壮性，减少bug率**
         1. 优点：在源码中保留类型信息，声明变量要指定类型，对变量做的操作要和类型匹配，会有专门的编译器在编译期间做检查。消除了类型不安全的隐患
         2. 缺点：代码写起来具有一定难度。除了要考虑代码要表达的逻辑之外，还要考虑类型逻辑：变量是什么类型的、是不是匹配、要不要做类型转换等。

1. ts为什么被叫做类型体操？
   1.  TypeScript 给 JavaScript 增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。ts并没有改变js的语法，只是在js的基础上添加了类型语法，所以也称为js的超集

# vue

## 为什么vue中不需要使用Fiber

1. 时间分片是为了解决CPU进行大量计算的问题，因为React本身架构的问题，在默认的情况下会进行大量的计算，就算使用React提供的性能优化API，进行设置，也会因为开发者本身的问题，依然可能存在过多计算的问题

1. vue通过响应式依赖跟踪，在默认的情况下可以做到只进行组件书级别的更新计算，而默认下React是做不到的，再者，Vue是通过template进行编译的，可以在编译的时候进行非常好的性能优化，比如对静态节点进行静态节点提升的优化处理，而通过 JSX 进行编译的 React 是做不到的。

1. React 为了解决更新的时候进行过多计算的问题引入了时间分片，但同时又带来了额外的计算开销，就是任务协调的计算，虽然 React 也使用最小堆等的算法进行优化，但相对 Vue 还是多了额外的性能开销，因为 Vue 没有时间分片，所以没有这方面的性能担忧。

## vuex怎么实现的

[vuex 源码:如何实现一个简单的 vuex - 掘金](https://juejin.cn/post/6844903560669298696)

vuex利用了vue的[mixin](https://cn.vuejs.org/api/options-composition.html#mixins)机制，混合 beforeCreate 钩子 将store注入至vue组件实例上，并注册了

vuex store的引用属性 $store!

在beforeCreate钩子函数中，通过vue 的mixin机制。——即每个vue组件实例化过程中，会在beforeCreate钩子前调用vuex Init方法，this指向vue实例 mixin:混入，一个混入对象可以包含任意组件选项，当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项

- new一个vue实例

- 给实例添加data：{state：xxx}

- vue.mixin混入到Vue.prototype.$store上

```JavaScript
class Store {
  constructor(Vue, options) {
    var bus = new Vue({
      data: {
        state: options.state
      }
    })

    this.install(Vue, bus)
  }

  install(Vue, bus) {
    Vue.mixin({
      beforeCreate() {
        if (this.$options.store) {
          Vue.prototype.$store = bus
        }
      }
    })
  }
}

const store = new Store(Vue, {
  state: {
    count: 0
  }
})
```

## Pinia

[pinia - 掘金](https://juejin.cn/post/7112843235675865102)

## vue的响应式更新到组件级别

https://juejin.cn/post/6844904113432444942#heading-7

vue对已响应式属性的更新，只会精确更新依赖收集的当前组件，而不会递归的去更新子组件。

- react的更新粒度
  -  react遵循Immutable的设计思想，永远不在原对象上修改属性，所以给予Object.defineProperty或Proxy的响应式以来机制就无从下手了，同时，由于没有响应式的收集依赖，React 只能递归的把所有子组件都重新 render一遍（除了memo和shouldComponentUpdate这些优化手段），然后再通过 diff算法 决定要更新哪部分的视图，这个递归的过程叫做 reconciler，听起来很酷，但是性能很灾难

  - > immutable.js 可以解决此问题，immutable.js 不可变的状态，对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。鉴于这个功能，所以可以把需要对比的 props 或者 state 数据变成 Immutable 对象，通过对比 Immutable 是否相等，来证明状态是否改变，从而确定是否更新组件

## [组件通信](https://juejin.cn/post/6999687348120190983)

## Vue nextTick      

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。

实现原理:

vue是异步执行dom更新的，一旦观察到数据变化，vue就会开启一个队列，将同一个事件循环中观察到 数据变化的watcher推送进这个队列，如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和Dom 操作，而在下一个事件循环时，vue会清空队列，并进行必要的dom更新。

- 将回调函数放入callbacks等待执行

- 将执行函数放到微任务或者宏任务中

- 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调    

使用场景：  

- 在created钩子函数进行的dom操作一定要放在vue.nextTick()的回调函数中。原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。

- 点击按钮显示原本v-show = false 隐藏起来的输入框，并获取焦点。

## [Eventbus&mitt](https://juejin.cn/post/7111129583713255461)

兄弟组件可以通过一个事件中心EventBus实现，新建一个Vue实例来进行事件的监听，触发和销毁。在vue3中没有了EventBus，使用mitt.js来代替

cookie过期时间设置为0，表示跟随系统默认，其销毁与session销毁时间相同，都在浏览器关闭后的特定时间删除，如果我们写程序的时候不设置cookie的有效时间，那么，cookie的有效时间等效于会话时间

## [vue路由history模式刷新404问题解决方案](https://router.vuejs.org/zh/guide/essentials/history-mode.html#express-node-js)

在服务器上添加一个简单的回退路由，如果url不匹配任何静态资源，她应提供与应用程序中的index.html相同的页面

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ3ZTc4OTFjZTdiM2RhMzVhMDk0ZDI2NTYyMjdmMjJfUHdlZFRkaWdzVThRcE1ra1ZtMDlsZUJvQ1RnbFJpQU9fVG9rZW46Ym94Y25KSHJkMUJyVVQxdnFlMEdUN1NqTXViXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## [vue插件机制及其原理](https://www.cnblogs.com/cp-cookie/p/16262378.html)

vue的插件机制功能

- 通常用来为vue添加全局功能

- 添加全局资源：指令，过滤器，过渡等

- 通过全局混入来添加一些组件选项，如vue-router

- 添加vue实例方法，通过把她们添加到Vue。prototype上实现

使用方法：

通过全局方法Vue.use()使用用，需要在new Vue()启动应用之前完成

原理：

本质上插件就是一个对象，在对象里面调用install方法

vue.js的插件应该暴露一个install方法，这个方法的第一个参数就是Vue构造器，第二个参数是一个可选的选项对象

install在vue中的内部实现

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU2MmJiYTAxNDg2ZWZmY2YwZTdlYzk5MGM4YjFkYzJfQzBOMWU5d0tKdWJIU1dlbVZLNExyZUhaQnkxeklwdm9fVG9rZW46Ym94Y25uN0xZSWNqOXpJd3dxblczMDJMTHFmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## [keep-alive原理](https://juejin.cn/post/7043401297302650917)

keep-alive是一个vue全局组件，本身不会渲染出来，不会出现在父组件链中，包裹动态组件时，会缓存不活动的组件，而不是销毁他们

接收三个参数

- include：可传字符串，正则，数组，名称匹配成功的组件会被缓存

- exclude：可传字符串，正则，数组，名称匹配成功的组件不会被缓存

- max：可传数字，限制缓存组件的最大数量

Keep-alive在各个生命周期做的事情：

- created：初始化一个cache、keys，前者用来存缓存组件的虚拟dom集合，后者用来缓存组件的key集合

- mounted：实时监听include，exclude这两个的变化，并执行相应操作

- destroyed：删除掉所有缓存相关的东西

render过程：

1. 获取到keep-alive包裹的第一个组件以及他的组件名称

1. 判断此组件名称是否能被白名单，黑名单匹配，如果不能被白名单或黑名单匹配，则直接返回Vnode，不往下执行，如果符合则执行第三步

1. 根据组件ID，tag生成缓存key，并在缓存集合中查找是否已缓存过此组件，如果已被缓存过，直接取出缓存组件，并更新缓存key在keys的位置，如果没缓存过，则继续第四步

1. 分别在cache，keys中保存此组件以及他的缓存key，并检查数量是否超过max，超过则根据LRU算法（最少使用算法）进行删除

1. 将此组件实例的keepAlive属性设置为true

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQzNGEwZjczZjJmMjQ5YmM1MjQ2YmQzZmM4ZjVkNmZfZjZQU2syRFB6bGZta09leHY0cXl0WkRrQldWMXlUNmdfVG9rZW46Ym94Y253dUpLMjlic1ZxTnlCYmFEaVhmd21lXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## Watch和watchEffect

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFiYTc2ZDg4ODVhMDY3ZjdkZmM2OWQ5MWU5NTZlNjJfQ3RhRnhVRFR4M2hNNFpkVW5jWkJuQ2tyd3JmWXF6RUdfVG9rZW46Ym94Y25Mb1RRNnk0aWl5eWVnT0R2SXhnV3JnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## Diff

[15张图，20分钟吃透Diff算法核心原理，我说的！！！](https://juejin.cn/post/6994959998283907102)

[深入浅出虚拟 DOM 和 Diff 算法，及 Vue2 与 Vue3 中的区别 - 掘金](https://juejin.cn/post/7010594233253888013)

## 生命周期

不要再选项property或回调上使用箭头函数，因为箭头函数没有this，this会作为变量一直向上级词法作用域查找，直到找到位置，经常导致`Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。 

# React

> Vue 数据可变和react数据不可变的区别
>
> 优化react组件渲染行为useMemo，useCallback memo，useEffect（主动）
>
> 函数式组件和class组件的区别
>
> vue2&vue3区别，react16.8前后 react18新特性
>
> React query      
>
> react toolkit
>
> React fiber，vue为什么不用fiber
>
> diff算法
>
> 生命周期16.8前后
>
> Jsx
>
> class

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VmNmRmMzFmODFmZGU3MjFhNGViMDY5ZWM4ODA5ZWNfOUZRdGsxdU9CY3hBdlE3QkpCY1RBMlNWZVAzbUlKY21fVG9rZW46Ym94Y25GSXp1UEdNZW1LbmM4NlZWV1BHZERjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## [react 18](https://juejin.cn/post/7094037148088664078)

1. react18已经放弃了支持ie11

1. Render API
   1. 新增了root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。在卸载组件的时候也需要将unmountComponeAtNode升级root.unmount
   2. React 18从render方法中删除了回调函数，因为当使用**`Suspense`**时，它通常不会有预期的结果。在新版本中，如果需要在 **`render`** 方法中使用回调函数，我们可以在组件中通过 **`useEffect`** 实现
   3. 如果使用了ssr服务端渲染，需要把hydration升级为hydrateroot
   4. 如果需要获取子组件children，需要显示定义

1. setState自动批处理
   1.  在React 18 之前，我们只在 React 事件处理函数 中进行批处理更新。默认情况下，在promise、setTimeout、原生事件处理函数中、或任何其它事件内的更新都不会进行批处理

1. flushSync
   1.  批处理是一个破坏性改动，如果想退出批处理更新，可以使用flushSync

   2.  flushSync 函数内部的多个 setState 仍然为批量更新，这样可以精准控制哪些不需要的批量更新。

1. 在 React 17 中，如果你需要返回一个空组件，React只允许返回null。如果你显式的返回了 undefined，控制台则会在运行时抛出一个错误。
   1.  在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined（但是 React 18 的dts文件还是会检查，只允许返回 null，你可以忽略这个类型错误）。

1. Suspense 不再需要 fallback 来捕获
   1.  在 React 18 的 Suspense 组件中，官方对 空的fallback 属性的处理方式做了改变：不再跳过 缺失值 或 值为null 的 fallback 的 Suspense 边界。相反，会捕获边界并且向外层查找，如果查找不到，将会把 fallback 呈现为 null。

1. 新的API
   1. useId：支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 **`hydration`** 的不兼容。因为我们的服务器渲染时提供的 **`HTML`** 是**`无序的`**，**`useId`** 的原理就是每个 **`id`** 代表该组件在组件树中的层级结构。
      1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTlmYmYwZmZhMTQyMjBiZjJmODZjODIwMmM1ODBjN2RfeTE4Y21XYW5mckp6Y28xeFVMM2tjS09DS25La1FJN2FfVG9rZW46Ym94Y24ySkVJV1dVc0NEaWdJSXpJRWlpQ25kXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 并发模式

- 将同步不可中断更新变成了异步可中断更新

- - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY0NWNmYzQyMmM3ZTJhZDUxZGMzOTM5MThiMjhhNzRfbjVnNFUyQnFFV21iUlJVOHZRczlFRG9UOEw2aGh1QU1fVG9rZW46Ym94Y240ZWFUa0xweHVoSlZJbzFDdGQ5T09JXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

  -  并发特性：

  - startTransition：
    1.   `startTransition`，主要为了能在大量的任务下也能保持 UI 响应。这个新的 API 可以通过将特定更新标记为`“过渡”`来显著改善用户交互，简单来说，就是被 `startTransition` 回调包裹的 `setState` 触发的渲染被标记为不紧急渲染，这些渲染可能被其他`紧急渲染`所抢占。
  - useDeferredValue：返回一个延迟响应的值，可以让一个**`state`** 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。**`useDeferredValue`** 和 **`startTransition`** 一样，都是标记了一次非紧急更新。
    1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTYxMjdjNGUwZmE2YzhkMzE4ZTA5ODk0NzA0NWMzYmRfcFFnd2VjYU5GQTgyTGRLb0x2NDZNelNudFB0STdRTE1fVG9rZW46Ym94Y25OYmhDb0VjSnZSalNMZkt0elFDV2dZXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
  -  并发模式是一组功能，可帮助 `React` 应用程序保持响应并平滑地适应用户的设备和网络速度能力。并发模式将其拥有的任务划分为更小的块。 `React` 的调度程序可以挑选并选择要执行的作业。作业的调度取决于它们的优先级。通过对任务进行优先级排序，它可以停止琐碎或不紧急的事情，或者进一步推动它们。 `React` 始终将用户界面更新和渲染放在首位。

  -  并发更新的意义就是`交替执行`不同的任务，当预留的时间不够用时，`React` 将线程控制权交还给浏览器，等待下一帧时间到来，然后继续被中断的工作

  -  `并发模式`是实现`并发更新`的基本前提

  -  `时间切片`是实现`并发更新`的具体手段

  -  上面所有的东西都是基于 `fiber` 架构实现的，`fiber`为状态更新提供了可中断的能力

## Suspense

`React.Suspense` 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件，可以使得组件则可以等待某些操作结束后，再进行渲染

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRkMjhjYzk5NDljZmU4MzlkZTZiMjQ4MWYxMTM5OGJfN1Qyc21SU3VLV2hxVXV4ZGxaQ1Q5cDE5YmFzQXR3b0dfVG9rZW46Ym94Y25qNFFSTGNXcjdrWGhwQnltN3d1Q1djXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 代码拆分

1. 

## React介绍？痛点？

react主张函数式编程，所以推崇纯组件，数据不可变，单项数据流

## react与vue的异同

[个人理解Vue和React区别 | springleo' s blog](https://lq782655835.github.io/blogs/vue/diff-vue-vs-react.html)

相同点：

- 都使用了虚拟dom
  -  虚拟dom是一层真实dom的抽象，以js对象作为基础的树，用对象的属性来描述节点，最终通过一系列操作将这棵树映射到真实环境上，**最少包含**tag(标签名)，属性(attrs)和子元素对象(children)

  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MDNmY2I2MDI4NzljOTExZDBkYmIzZjU0MDY0NjNmYWFfa2JTeDJIeUVhNXpiVmQ2TFpoSFF2Y3dGdDZkS3BnTG9fVG9rZW46Ym94Y245SHlyQU5NWTh3R2NzMFlkZXd5QmFnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

  -  react通过jsx或React.createElement创建虚拟dom

  -  作用：

  -  dom元素非常庞大，而且页面很多的性能问题都是dom操作引起的，虚拟dom除了diff算法可以优化页面性能以外，其实抽离了原本的渲染过程，实现了跨平台的能力

- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。

- 都是单向数据流

- 都使用组件化思想

- 都使用了hook的思想
  - vue3中新增了reactive，ref，watchEffect等，

不同点:

- Vue的整体思想仍然是拥抱经典的html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板；react整体上是函数式的思想，组件使用jsx语法，all in js，将html与css全都融入javaScript

- React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染

- vue中是双向绑定的，通过v-model实现，相当于onchange的语法糖；react需要我们通过setState来更新数据

- Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。

- Vue-cli脚手架可进行配置

## Jsx

JSX的全称是 Javascript and XML，React发明了JSX，它是一种可以在JS中编写XML的语言。JSX更像一种模板，类似于Vue中的 template。JSX是JS的语法糖，编译时JSX会通过Babel编译成JS。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUwZTdlZmY3NzQ3YjFlZGRlNjgzNjY4YzIzYWFhYzRfTlZab21GTXBvWU1nSUNrZGtSdmFFU0ZtZTJ3V2VWd0pfVG9rZW46Ym94Y250OTJ3alFPM0hMcXZBcUFqakQ2S0poXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### [Jsx转换为真实Dom的过程](https://juejin.cn/book/6945998773818490884/section/6948337148202319908?scrollMenuIndex=0)

我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程， React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。

React.createElement参数：

- 如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。每种类型都会有对应的tag。

- 第二个参数：一个对象，在dom类型中为标签属性，在组件中为props

- 其他参数依次为children，根据顺序排列

## 函数式组件与类组件的区别

1. 类组件的根基是oop面向对象编程，所以会有继承，内部状态等；函数组件的根基是FP函数式编程，相同输入必有相同输出

1. 函数式组件没有生命周期，类组件有生命周期

1. 在函数组件的闭包中，捕获的值永远都是确定且安全的，每一次都是新的数据，class会使用之前的数据直到组件销毁

1. 性能优化：类组件是通过 shouldComponentUpdate 生命周期函数去阻断渲染；函数式组件式通过React.Memo函数来优化

**本质区别：**

**对于类组件来说，底层只需要实例化一次，实例中保存了组件的state状态，对于每一次更新只需要调用render方法以及对应的生命周期就可以了，但是在函数组件中，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量就会重新声明**

在编写类组件的时候，开发者编写的逻辑在封装之后是和组件粘连在一起的，比较难以拆分和复用

### **在老版本的react中，为什么写jsx的文件要默认引入React**

因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjdkODhmZjhiYWU1YWY5NDgyYTc3MmQ1YjYwMjRiMjFfeUVXZ20zd3cyVHlMb1l3Y0pMN3FnRHdxQXRZT3drbTlfVG9rZW46Ym94Y25LcEV5Y2ZJT3F6c3pvamNGVzJyUXZiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### babel解析jsx流程

jsx语法来源于这两个babel插件

- @babel/plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法

- @babel/plugin-transform-react-jsx：这个插件内部调用了 @babel/plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。

## 在哪个生命周期发起ajax请求

在react中，建议在componentDidMount这个生命周期函数中发起ajax请求，这样可以在拿到ajax请求返回的数据并通过setState来更新组件

## Hook

### 为什么有hooks？

1. 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。

1. 解决逻辑复用难的问题。

1. 放弃面向对象编程，拥抱函数式编程。

Hook使用了js的闭包机制，而不用在JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。

目前没有针对于`getSnapshotBeforeUpdate`，`getDerivedStateFromError` 和 `componentDidCatch` 生命周期的 Hook 等价写法

### hooks与fiber

hooks 可以作为函数组件本身和函数组件对应的 fiber 之间的沟通桥梁。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFmZjAzNTI3MDlkZDEyOGRjMWNmZDA0YjJkMjYxODlfRzI4a3lzeEdCMW51ZU9RY0pQRnlQbUFnb2E5b2hycFBfVG9rZW46Ym94Y25zMlNJcGM3NUpJdlBXcnNObm9qZmRiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

三种处理策略：

1. ContextOnlyDispatcher：第一种形态是防止开发者在函数组件外部调用 hooks ，所以第一种就是报错形态，只要开发者调用了这个形态下的 hooks ，就会抛出异常。

1. HooksDispatcherOnMount：第二种形态是函数组件初始化 mount ，因为之前讲过 hooks 是函数组件和对应 fiber 桥梁，这个时候的 hooks 作用就是建立这个桥梁，初次建立其 hooks 与 fiber 之间的关系。

1. HooksDispatcherOnUpdate：第三种形态是函数组件的更新，既然与 fiber 之间的桥已经建好了，那么组件再更新，就需要 hooks 去获取或者更新维护状态。

函数组件触发

在 fiber 调和过程中，遇到 FunctionComponent 类型的 fiber（函数组件），就会用 updateFunctionComponent 更新 fiber ，在 updateFunctionComponent 内部就会调用 renderWithHooks ，所有函数组件的更新实在该方法中的

```JavaScript
let currentlyRenderingFiber
function renderWithHooks(current,workInProgress,Component,props){
    currentlyRenderingFiber = workInProgress;
    workInProgress.memoizedState = null; /* 每一次执行函数组件之前，先清空状态 （用于存放hooks列表）*/
    workInProgress.updateQueue = null;    /* 清空状态（用于存放effect list） */
    ReactCurrentDispatcher.current =  current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate /* 判断是初始化组件还是更新组件 */
    let children = Component(props, secondArg); /* 执行我们真正函数组件，所有的hooks将依次执行。 */
    ReactCurrentDispatcher.current = ContextOnlyDispatcher; /* 将hooks变成第一种，防止hooks在函数组件外部调用，调用直接报错。 */
}
```

- 对于类组件 fiber ，用 memoizedState 保存 state 信息，**对于函数组件 fiber ，用 memoizedState 保存 hooks 信息**。

- 对于函数组件 fiber ，updateQueue 存放每个 useEffect/useLayoutEffect 产生的副作用组成的链表。在 commit 阶段更新这些副作用。

- 然后判断组件是初始化流程还是更新流程，如果初始化用 HooksDispatcherOnMount 对象，如果更新用 HooksDispatcherOnUpdate 对象。函数组件执行完毕，将 hooks 赋值给ContextOnlyDispatcher对象。引用的React hooks都是从ReactCurrentDispatcher.current 中的， React 就是通过赋予 current 不同的 hooks 对象达到监控 hooks 是否在函数组件内部调用。

- Component ( props ， secondArg ) 这个时候函数组件被真正的执行，里面每一个 hooks 也将依次执行

- 每个 hooks 内部为什么能够读取当前 fiber 信息，因为 currentlyRenderingFiber ，函数组件初始化已经把当前 fiber 赋值给 currentlyRenderingFiber ，每个 hooks 内部读取的就是 currentlyRenderingFiber 的内容。

### hooks初始化- hooks 如何和 fiber 建立起关系

每一个hooks 初始化都会执行 mountWorkInProgressHook 

```JavaScript
function mountWorkInProgressHook() {
  const hook = {  memoizedState: null, baseState: null, baseQueue: null,queue: null, next: null,};
  if (workInProgressHook === null) {  // 只有一个 hooks
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {  // 有多个 hooks
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

首先函数组件对应 fiber 用 memoizedState 保存 hooks 信息，每一个 hooks 执行都会产生一个 hooks 对象，hooks 对象中，保存着当前 hooks 的信息，不同 hooks 保存的形式不同。每一个 hooks 通过 next 链表建立起关系

### hooks 为什么要通常放在顶部，hooks 不能写在 if 条件语句中

在更新过程中，如果通过 if 条件语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks 状态和当前 hooks 不一致的问题

hooks是基于数组（链表）实现的，在调用时hooks按顺序加入数组中，如果使用循环，条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook，进入到第一种形态ContextOnlyDispatcher并报错

### 状态派发

useState 解决了函数组件没有 state 的问题

每一次改变state，底层的处理

- 首先用户每一次调用 dispatchAction（比如如上触发 setNumber ）都会先创建一个 update ，然后把它放入待更新 pending 队列中。

- 然后判断如果当前的 fiber 正在更新，那么也就不需要再更新了

- 反之，说明当前 fiber 没有更新任务，那么会拿出上一次 state 和 这一次 state 进行对比，如果相同，那么直接退出更新。如果不相同，那么发起更新调度任务。**这就解释了，为什么函数组件 useState 改变相同的值，组件不更新了。**

- useState中的dispatchAction会默认比较两次state是否相同，然后决定是否更新组件

### 副作用是什么？

可以理解为除了js线程的其他线程处理的事情：

- 对外部可变数据或变量的修改: 全局变量 / 闭包变量 / dom对象 / bom对象的读写操作

- 外部接口的调用尤其是IO：
  - dom对象 / bom对象的方法调用; 
  - xhr / fetch这样的网络IO；
  - console / LocalStorage这样的磁盘IO

- 异常的抛出：函数中的某些代码可能会抛出异常或者执行出错

### 处理副作用

- mountWorkInProgressHook 产生一个 hooks ，并和 fiber 建立起关系。

- 通过 pushEffect 创建一个 effect，并保存到当前 hooks 的 memoizedState 属性下

- pushEffect 除了创建一个 effect ， 还有一个重要作用，就是如果存在多个 effect 或者 layoutEffect 会形成一个副作用链表，绑定在函数组件 fiber 的 updateQueue 上。

### 更新流程

- 判断 deps 项有没有发生变化，如果没有发生变化，更新副作用链表就可以了；如果发生变化，更新链表同时，打执行副作用的标签：`fiber => fiberEffectTag，hook => HookHasEffect`。在 commit 阶段就会根据这些标签，重新执行副作用。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJiMDU1Y2U2N2NkZWMxZWViYmU0ZGI0Y2NiZjE5Y2JfVVJQcjQyZDhnTFM2SFN4ZzNUQzlZbG53c2NKTEFqeGNfVG9rZW46Ym94Y242c0tkcFBRSTdxYmRHYmI3OFRwRkplXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### **生命周期方法对应hook？**

- `constructor`：函数组件不需要构造函数。你可以通过调用 `useState` 来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 `useState`。

- `getDerivedStateFromProps`：改为 [在渲染时](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops) 安排一次更新。

- `shouldComponentUpdate`：详见 [下方](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate) `React.memo`.

- `render`：这是函数组件体本身。

- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`：`useEffect Hook` 可以表达所有这些(包括 [不那么](https://zh-hans.reactjs.org/docs/hooks-faq.html#can-i-skip-an-effect-on-updates) [常见](https://zh-hans.reactjs.org/docs/hooks-faq.html#can-i-run-an-effect-only-on-updates) 的场景)的组合。

- `getSnapshotBeforeUpdate`，`componentDidCatch` 以及 `getDerivedStateFromError`：目前还没有这些方法的 Hook 等价写法，但很快会被添加。

### hooks实现原理

*dispatcher 是包含了hooks函数的共享对象，Hooks queue用顺序下**链接**在一起的节点。*

*它的初始状态在首次渲染时被创建。*

*她的状态可以即时更新。*

*React会在之后的渲染中记住hook的状态*

*React会根据调用顺序为您提供正确的状态*

*React会知道这个hook属于哪个Fiber。*

### react是如何将hook的调用和组件联系起来的？

每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 `useState()` 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 `useState()` 调用会得到各自独立的本地 state 的原因

### Hook API

1. **useState：**
   1. React使用Object.is比较算法来比较state
   2. 批处理状态更新：React可以将多个状态更新分组到单个重新渲染中以提高性能，通常这会提高性能，不会影响应用程序的行为。在react18之前只对react事件处理程序中的更新进行批处理。从react18之后开始，默认情况下为所有更新启用批处理。在罕见的情况下，您需要强制同步应用DOM更新，您可以将其包装为flushSync。但是，这可能会影响性能，因此只能在需要时这样做。
   3. **使用useState时候，使用push，pop，splice等直接更改不能获取到新值，应该采用析构方式**
   4. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MzZmMzVlM2JhNjMzZGQyNTk0YzFiNWNkODNiZTRlZjRfbDlCbzRTdHE0eTJIbjJBTVl0a3g4dDlkMW9IcERoWm1fVG9rZW46Ym94Y25yaTl0dFVDdndTUGJVMUFhcHVoSGpnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   5. **useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect**
   6. 如果 useState 返回数组，那么你可以顺便对数组中的变量命名，代码看起来也比较干净。而如果是对象的话返回的值必须和 useState 内部实现返回的对象同名，这样你只能在 function component 中使用一次，想要多次使用 useState 必须得重命名返回值。
      - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM0Y2RkMmNhNDBjODIzNWRmMzYzM2UzMWVkYmY5Y2RfVWlOOWhiZW9uNW9xczFXMm9NUTl2RUFEUzg4ZjdNM3JfVG9rZW46Ym94Y25DU2JBS3daN29mTTR4cWxCYlhncDhmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. **useEffect：给函数组件增加了操作副作用的能力。**
   1. 它跟 class 组件中的 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount` 具有相同的用途，只不过被合并成了一个 API。
   2. 副作用：数据获取，设置订阅以及手动更改React组件中的DOM都属于副作用
   3. 使用 `useEffect` 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。
   4. 为什么在effect中返回一个函数？这是effect可选的删除机制，每个effect都可以返回一个清除函数，如此才可以将添加和移除订阅的逻辑放在一起
   5. react会在组件卸载的时候执行清除操作，react会在执行当前effect之前对上一个effect进行清除
   6. 如果想要通过跳过 Effect 进行性能优化，第二个参数需要包含所有外部作用域中会随时间变化并且在effect中使用的变量，否则你的代码会引用到先前渲染中的旧变量。如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（`[]`）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。
   7. useEffect的函数会在浏览器完成布局与绘制之后，在一个延迟时间中被调用，但并非所有的effect都可以延迟被执行，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。

1. **useLayoutEffect：**
   1. 函数签名与useEffect相同，但是会在所有的DOM变更之后同步调用effect，可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，`useLayoutEffect` 内部的更新计划将被同步刷新。
   2. useLayoutEffect callback中代码执行会阻塞浏览器执行
   3. 如果你使用服务端渲染，请记住，*无论* `useLayoutEffect` *还是* `useEffect` 都无法在 Javascript 代码加载完成之前执行

1. **useContext：**
   1. 接收一个 context 对象（`React.createContext` 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value` prop 决定。当组件上层最近的 `<MyContext.Provider>` 更新时，该 Hook 会触发重渲染，并使用最新传递给 `MyContext` provider 的 context `value` 值。即使祖先使用 `React.memo` 或 `shouldComponentUpdate`，也会在组件本身使用 `useContext` 时重新渲染。
   2. useContext的参数必须是context对象本身
   3. 调用了 `useContext` 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 [通过使用 memoization 来优化](https://github.com/facebook/react/issues/15156#issuecomment-474590693)。
   4. ```JavaScript
      const themes = {
          light: {
              background: "#eeeeee"
          },
          dark: {
              background: "#222222"
          }
      };
      const ThemeContext = React.createContext(themes.light);
      function App() {
          return (
              <ThemeContext.Provider value={themes.dark}>
                <Toolbar />
              </ThemeContext.Provider>);
      }
      function Toolbar(props) {
          return (
              <div>
                <ThemedButton />
              </div>);
      }
      function ThemedButton() {
        const theme = useContext(ThemeContext);  
            return (    
                <button style={{ background: theme.background }}>I</button>  
            );
      }
      ```

1. useReducer：
   1. useState的替代方案，它接收一个形如 `(state, action) => newState` 的 reducer，并返回当前的 state 以及与其配套的 `dispatch` 方法
   2. 使用useReducer还可以出发神更新的组件做性能优化，因为可以向子组件传递dispatch而不是回调函数
   3. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUyMjk3ODYyMDlmMDEzYTQ3Y2IzMjJmMTk5NjJlZTBfc0NEODRCV3hxdmRvdThnbDVZNXZRdWhKakJUbll5REpfVG9rZW46Ym94Y241NGxFZExuS29YQ3RZYkNaQ2IwdHVnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   4. 指定初始state：
      - 将初始state作为第二个参数传入useReducer
      - ```JavaScript
        const [state, dispatch] = useReducer(
            reducer,
            {count: initialCount}  
        );
        ```
   5. 惰性初始化：将初始参数作为useReducer的第三个参数传入
      - ```JavaScript
        function init(initialCount) { 
           return {
               count: initialCount
           };
        }
        function reducer(state, action) {
            switch (action.type) {
                case 'increment':    
                    return {count: state.count + 1};
                case 'decrement':
                    return {count: state.count - 1};
                case 'reset':     
                    return init(action.payload);    
                default:throw new Error();
            }
        }
        function Counter({initialCount}) {
          const [state, dispatch] = useReducer(reducer, initialCount, init);  
          return (
              <>
                  Count: {state.count}
                  <button onClick={() => dispatch({type: 'reset', payload: initialCount})}>        
                      Reset
                  </button>
                  <button onClick={() => dispatch({type: 'decrement'})}>-</button>
                  <button onClick={() => dispatch({type: 'increment'})}>+</button>
              </>);
        }
        ```

1. useCallback：
   1. 返回一个memorized回调函数。把内联回调函数及依赖项数组作为参数传入 `useCallback`，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 `shouldComponentUpdate`）的子组件时，它将非常有用。
   2. `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`。
   3. ```Plain
      const memoizedCallback = useCallback(
          () => {
              doSomething(a, b);
          },
          [a, b],
      );
      ```

1. useMemo：返回一个memorized值
   1. 传入 `useMemo` 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作，诸如副作用这类的操作属于 `useEffect` 的适用范畴，而不是 `useMemo`
   2. 你可以把 `useMemo` 作为性能优化的手段，但不要把它当成语义上的保证
   3. ```JavaScript
      const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
      ```

   4.  useMemo的第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把Children 对应的 element 对象，缓存起来。

   5.  useMemo的第一个参数为一个数组，存放当前useMemo的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。

   6.  `cacheSomething`：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。

   7. 

1. useRef：
   1. `useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数（`initialValue`）。返回的 ref 对象在组件的整个生命周期内持续存在。
   2. ```JavaScript
      function TextInputWithFocusButton() {
          const inputEl = useRef(null);
          const onButtonClick = () => {
              // `current` 指向已挂载到 DOM 上的文本输入元素
              inputEl.current.focus();
          };
          return (
              <>
                <input ref={inputEl} type="text" />
                <button onClick={onButtonClick}>Focus the input</button>
              </>
          );
      }
      ```

   3. useRef()和自建一个{current:...}对象的唯一区别是，useRef会在每次渲染时返回同一个ref对象
   4. 变更 `.current` 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用[回调 ref](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node) 来实现。

1. useImperativeHandle：
   1. `useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。应当与forwardRef一起使用
   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRjODZiNjhkZmU3MmE5NmNiYzUwZmU5MTdkNjY0MTdfcHBtaFl1QXpoRGF6NHltcWxKb1lMYmFhclRzd3psRVRfVG9rZW46Ym94Y25FT3dLYlBNemE5U3ZUc05CZEhWYnZjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MGI2MzIwY2YyNjIyYjNkOTE1ZTA4YWIwZjhiMzBjOTVfazBaeWM2cnI3T1V6akR5SERxRWw0b1FQVGNua3NDWUhfVG9rZW46Ym94Y25lWGxyM2tmVWd4TDQ0S2JRaFNyNW9lXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   3. 

1. useDebugValue
   1. 可用于在react开发者工具中显示自定义hook的标签
   2. 我们可以通过useDebugValue来延迟格式debug值
   3. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NjliYzA1ZjUxNDFlYzcxNzc5ODg1NDNmYmU4MTkyNmNfSTNsZldwekFSR3g4UnZIeFJwdFplZzdLMXp6YTlvOEtfVG9rZW46Ym94Y256VE42QzRsV2Vtc3oxZmdKS0JwZGxnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. useDeferredValue
   1. `useDeferredValue` 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。使用 `useDeferredValue` 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，并且像 `startTransition` 一样，延迟值可以暂停，而不会触发现有内容的意外降级。
   2. useDeferredValue仅延迟你传递给他的值，如果想要在紧急更新期间防止子组件重新渲染，则还必须使用 React.memo 或 React.useMemo 记忆该子组件

1. useTransition
   1. 返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数startTransition 允许你通过标记更新将提供的回调函数作为一个过渡任务：

1. useId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。

## React.memo,useMemo,useCallback的区别？

React.memo：缓存的是整个组件

useMemo：缓存的是第一个参数（函数）的返回值

useCallback：缓存的是一个函数本身

## Css模块化

重要作用：

- 防止全局污染，样式被覆盖

- 命名混乱

- css代码冗余，体积庞大

解决方案：

- Css module：依赖于webpack构建和css-loader等loader处理，将css交给js来动态加载

- 放弃css：css in js用js对象方式写css，然后作为style方式赋给React的Dom元素，这种写法将不需要 .css .less .scss 等文件，取而代之的是每一个组件都有一个写对应样式的 js 文件。

### [Css module](https://juejin.cn/book/6945998773818490884/section/6956440391461634063?scrollMenuIndex=0)

css Modules ，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css 类名，从根本上解决 css 全局污染，样式覆盖的问题。对于 css modules 的配置，推荐使用 css-loader，因为它对 CSS Modules 的支持最好，而且很容易使用

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY4NWQ3YzY1MTNlZDI1NjMwZTQ1MTBjNDMzZjA2ZThfeDlNN2tVNGdndTdreHJ2ZXJUeGJZMm5zNnFFYXNLVGZfVG9rZW46Ym94Y25OMDVaN0pxRUFOa20wUXljS280TWZSXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## React底层是如何进行批量更新的？

在 React 事件执行之前会调用batchUpdate方法设置 `isBatchingEventUpdates=true` 打开开关，开启事件批量更新，当该事件结束，再通过 `isBatchingEventUpdates = false;` 关闭开关，然后在 scheduleUpdateOnFiber 中根据这个开关来确定是否进行批量更新

**异步操作会打破批量更新的规则**

在异步环境下，可以通过React-DOM中的批量更新方法unstable_batchedUpdates手动批量更新

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI4OTdkMjgzZDM1MmNjZTRiZWJmMjNiODk3MjQ5NDBfY3dPSTN0MGI3YXBoZFhoTlo5bmc1bk90MjhyQXYzbUNfVG9rZW46Ym94Y25SVHFhdTRPT3Vlck5TSzlPbFo0U0RiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

我们可以将更新任务放在flushSync回调函数内部，以此提高更新的优先级

flushSync中的setState>正常执行上下文中的setState>setTimeout，Promise中的setState

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ2Y2Q1Yjg4YWRjY2VmMTE0YzhjMzMyYTZjNTYzMzFfOTI2dE9XRE1YS3poemZGZktzb3B6ZXV2b3plbGdrZG9fVG9rZW46Ym94Y25RRVB1RzM1dGVFcDFlQTBGZzhDbDFnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkwZGJhZGFiYjI2ZDgzMWNhNzNkY2I0NDUwZWZjNjVfUmNOZ3Y3V2FXdUNVaXM2TnRweXowQk1KSm5YUkxMckdfVG9rZW46Ym94Y25sN1NlRXJvWEFyMk1Bd1FrS25kcFNiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## diff

[为什么 React 的 Diff 算法不采用 Vue 的双端对比算法? - 掘金](https://juejin.cn/post/7116141318853623839)

深度优先

1. 从左向右老节点进行比对查找能复用的旧节点，如果有老节点比对不成功的，则停止这一轮的比对，并记录停止的位置

1. 如果第一轮比对，能把所有的新节点都比对完毕，则删除旧节点还没进行比对的节点

1. 如果第一轮的比对，没能将所有的新节点都比对完毕，则继续从第一轮比对停值的位置继续开始循环新节点，拿每一个新节点去老节点里面进行查找，有匹配的则复用，没匹配成功的则在协调位置的时候打上Placement的标记

1. 在所有新节点比对完毕之后，检查还有没有没进行复用的旧节点，如果有，则全部删除

### 虚拟dom和fiber的区别

fiber是对虚拟dom的一种升级

- 虚拟dom使用栈来调度需要更新的内容，中间无法中断，暂停，fiber支持中断，在浏览器渲染帧里面分片执行更新任务

- fiber结构让虚拟节点记录父节点，兄弟节点，子节点，形成链表树，你可以从任意定点遍历到任意子节点，并返回

- fiber的分片操作使用requestAnimationFrame（高优先级任务）和requestIdleCallback（低优先级任务）

- fiber对任务的执行优先级进行标记，高优先级的任务可以选看执行，实现架构上的无阻塞

### React和vue diff算法的异同

相同：

- 只有使用了虚拟DOM的这些框架，在进行更新 Diff 对比的时候，都是优先处理简单的场景，再处理复杂的场景

- React 中是先处理左边部分，左边部分处理不了，再进行复杂部分的处理；Vue2 则先进行首尾、首首、尾尾部分的处理，然后再进行中间复杂部分的处理；Vue3 则先处理首尾部分，然后再处理中间复杂部分，Vue2 和 Vue3 最大的区别就是在处理中间复杂部分使用了最长递增子序列算法找出稳定序列的部分。

- **在处理老节点部分，都需要把节点处理 key - value 的 Map 数据结构，方便在往后的比对中可以快速通过节点的 key 取到对应的节点。同样在比对两个新老节点是否相同时，key 是否相同也是非常重要的判断标准。所以不同是 React, 还是 Vue，在写动态列表的时候，都需要设置一个唯一值 key，这样在 diff 算法处理的时候性能才最大化**。

不同：

- 对静态节点的处理不一样：由于 Vue 是通过 template 模版进行编译的，所以在编译的时候可以很好对静态节点进行分析然后进行打补丁标记，然后在 Diff 的时候，Vue2 是判断如果是静态节点则跳过过循环对比，而 Vue3 则是把整个静态节点进行提升处理，Diff 的时候是不过进入循环的，所以 Vue3 比 Vue2 的 Diff 性能更高效。而 React 因为是通过 JSX 进行编译的，是无法进行静态节点分析的，所以 React 在对静态节点处理这一块是要逊色的。

- vue2和vue3的比对和更新是同步进行的，这个和React15是相同的，如果比对量过大的话，就会造成卡顿，所以 React16 起比对和更新是异步进行的，所以 React16 以后的 Diff 是在遍历的时候，只对需要修改的节点进行记录，形成effectList，最后才会根据effectLIst进行真实的dom修改，修改时先删除，然后更新和移动，最后插入，可以中断，Diff 和任务调度都是在内存中进行的，所以即便中断了，用户也不会知道。

- Vue2 和 Vue3 都使用了双端对比算法，但是目前Fiber上没有设置反向链表，目前的单向链表的数据结构如果采用双端对比查找算法是比较难控制反向查找的，**我们不想用占用更多的内存空间的方式去优化性能**
  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YmNkOWU4ODM0ODkxODY2ODdhMDI4MzFhMjcxMDRiZmZfckFWem9CVEFydXVPdTR5UFVHZzNZUHVjU2piN0xQQkdfVG9rZW46Ym94Y25YWXl4c1NKZlpDcGRoVEFYRTlUNWhnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 组件通信方式

### props和callback方式

props 和 callback 可以作为 React 组件最基本的通信方式，父组件可以通过 props 将信息传递给子组件，子组件可以通过执行 props 中的回调函数 callback 来触发父组件的方法，实现父与子的消息通讯。

父组件 -> 通过自身 state 改变，重新渲染，传递 props -> 通知子组件

子组件 -> 通过调用父组件 props 方法 -> 通知父组件。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Njg3ZGU1YTI1YjliZTMwYzI1YjA1N2EzODAwMWUwYzhfb29NVGtvM2hUSFc4R3pnZ1dFRjhkeFk2NHJ3TTRVcEVfVG9rZW46Ym94Y25rY3J5REw1VUNUaU5pbHhKZ3l1MUtnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### ref方式

### react-redux或react-mobx状态管理方式

### context上下文方式

### Event bus方式——不提倡

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZhZDQ3MDMxNzFiMTRkMmYzOWFkYmU2NzNmNDYwNzlfMkl6RVVWSGdvaE9Hem90ZUx6aVF1d1VibzlWVFYwa0tfVG9rZW46Ym94Y24xRFI4YnVFVmxxaDNvNnVEUEJwdWdkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

缺点：

- 需要手动绑定和解绑

- 一定程度上违背了react数据流向原则

- 对于小型项目还好，但是对于中大型项目，这种方式的组件通信，会造成牵一发动全身的影响，而且后期难以维护，组件之间的状态也是未知的

## [react-redux](https://juejin.cn/book/6945998773818490884/section/6959910194696421406?scrollMenuIndex=0)

- redux：首先 Redux 是一个应用状态管理js库，它本身和 React 是没有关系的，换句话说，Redux 可以应用于其他框架构建的前端应用，甚至也可以应用于 Vue 中。

- redux规则
  - redux期望所有状态更新都是使用不可变的方式，具有不可变性immutability
  - 仅使用state和action参数计算新的状态只
  - 禁止直接修改state，必须通过复制现有的state并对复制的值进行更改
  - 禁止任何异步逻辑，依赖随机值活到这其他副作用的代码

- redux具有发布订阅思想：
  -  redux 可以作为发布订阅模式的一个具体实现。redux 都会创建一个 store ，里面保存了状态信息，改变 store 的方法 dispatch ，以及订阅 store 变化的方法 subscribe 。

### redux的三大模块

1. State

1. Action：action是一个对象，它必须要含有一个type属性，用来区别不同类型的action

1. reducer：reducer是一个函数，它接受2个参数，一个是state，一个是action，然后根据action的内容对state作出修改，并返回一个新的state
   1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBhODY4YzRjZmY4OGFkZGY1YWEyZDgzZTIzOTFhY2VfenhqR25mVk5WMmlSaVNhWW03S3M2aDBVQ1o4ZDRkU3dfVG9rZW46Ym94Y25pNW95cmx6Znc3cnNTUlk2blU4RldlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### redux的执行步骤

- 初始启动：
  - 使用最顶层的 root reducer 函数创建 Redux store
  - store 调用一次 root reducer，并将返回值保存为它的初始 `state`
  - 当 UI 首次渲染时，UI 组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便他们可以知道 state 是否已更改。

- 更新环节：
  - 应用程序中发生了某些事情，例如用户单击按钮
  - dispatch 一个 action 到 Redux store，例如 `dispatch({type: 'counter/increment'})`
  - store 用之前的 `state` 和当前的 `action` 再次运行 reducer 函数，并将返回值保存为新的 `state`
  - store 通知所有订阅过的 UI，通知它们 store 发生更新
  - 每个订阅过 store 数据的 UI 组件都会检查它们需要的 state 部分是否被更新。
  - 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页

- redux-toolkit：官方推荐的编写 **Redux** 逻辑的方法

- react-redux：React-Redux 是连接 React 应用和 Redux 状态管理的桥梁。React-redux 主要专注两件事，一是如何向 React 应用中注入 redux 中的 Store ，二是如何根据 Store 的改变，把消息派发给应用中需要状态的每一个组件。
  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTIzY2ZjZGExYmZhZGJjZTQ1MTdjYTdjNWZkYzAxZDRfbWx4dEJDYXBnSk9penR1R2JQS1RITnBlZ2Myb0FLMVBfVG9rZW46Ym94Y245STBMbmF5V3ZpMEFpbzd4WmVIWkxmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- react-redux用法：
  - 使用Provider全局注入redux中的store
  - 使用Connect高阶组件：
    1. 从 props 中获取改变 state 的方法 Store.dispatch
    2. 如果 connect 有第一个参数，那么会将 redux state 中的数据，映射到当前组件的 props 中，子组件可以使用消费。
    3. 当需要的 state ，有变化的时候，会通知当前组件更新，重新渲染视图
       1. ```JavaScript
          function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)
          const mapStateToProps = state => ({ number: state.number })
          const mapDispatchToProps = dispatch => {
            return {
              numberAdd: () => dispatch({ type: 'ADD' }),
              setInfo: () => dispatch({ type: 'SET' }),
            }
          }
          /*
          * stateProps , state 映射到 props 中的内容
          * dispatchProps， dispatch 映射到 props 中的内容。
          * ownProps 组件本身的 props
          */
          (stateProps, dispatchProps, ownProps) => Object
          ```

       2.  mapStateToProps: 组件依赖 redux 的 state，映射到业务组件的 props 中，state 改变触发，业务组件 props 改变，触发业务组件更新视图。当这个参数没有的时候，当前组件不会订阅 store 的改变
       3. mapDispatchToProps: 将 redux 中的 dispatch 方法，映射到业务组件的 props 中。
       4. mergeProps: 正常情况下，如果没有这个参数，会按照如下方式进行合并，返回的对象可以是，可以自定义的合并规则，还可以附加一些属性。` {...ownPropsm，...stateProps，...dispatchProps} `
       5. Options: 
          - ```JavaScript
            {
              // 自定义上下文
              context?: Object,  
              // 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。
              pure?: boolean, 
              // 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) => boolean
              areStatesEqual?: Function, 
              // 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) => boolean
              areOwnPropsEqual?: Function, 
              // 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) => boolean
              areStatePropsEqual?: Function, 
              // 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) => boolean
              areMergedPropsEqual?: Function, 
              //当为true 时候,可以通过ref 获取被connect包裹的组件实例。
              forwardRef?: boolean, 
            }
            ```

### [react-redux原理](https://juejin.cn/book/6945998773818490884/section/6959910194696421406?scrollMenuIndex=0)

1. Provider注入store
   1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM5OWY4YTA5OGJiMGI3ZmQ5NTExOGY0ZjViNGFjYmJfbHNncFlETlVOa1RIeGxaYXRiS1ptMGtzNGJnRFQ5SERfVG9rZW46Ym94Y25JQkVEbWRORGlYN0RzM2FHa3JWZlJkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. Subscription订阅器
   1.  核心：层层订阅，上订下发

   2.  层层订阅： Provider 里面有一个 Subscription ，提前透露一下，每一个用 connect 包装的组件，内部也有一个 Subscription ，而且这些订阅器一层层建立起关联，Provider中的订阅器是最根部的订阅器，如果父组件是一个 connect ，子孙组件也有 connect ，那么父子 connect 的 Subscription 也会建立起父子关系

   3.  上订下发：在调用 trySubscribe 的时候，能够看到订阅器会和上一级的订阅器通过 addNestedSub 建立起关联，当 store 中 state 发生改变，会触发 store.subscribe ，但是只会通知给 Provider 中的根Subscription，根 Subscription 也不会直接派发更新，而是会下发给子代订阅器（ connect 中的 Subscription ），再由子代订阅器，决定是否更新组件，层层下发

   4. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYyNzQ2MWM2OTg1MTU0YzYzNTg2NzE1OTAzZDgxZWJfYjZ3VFZkalhnWm9pSkkycDkyOWN4Z0JHeE9xYkJ6U0NfVG9rZW46Ym94Y250ZlhWcTVxTXdsS1RTZFFSeDhOYnJnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   5.  层层订阅模型：

   6. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRmNTZjYmI3MThhNGM0ZTgyYTdkMjAyYTEzOGU3NzNfNjhzcTNlenpzc01wOTB0TVZMVDdJcTlnMEVaMjA4VXNfVG9rZW46Ym94Y25SbnA4T0lFbERHcWZacjZjcUR3S1JnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   7. ###  为什么 React-Redux 会采用 subscription 订阅器进行订阅，而不是直接采用 store.subscribe 呢 

   8. 首先 state 的改变，Provider 是不能直接下发更新的，如果下发更新，那么这个更新是整个应用层级上的，还有一点，如果需要 state 的组件，做一些性能优化的策略，那么该更新的组件不会被更新，不该更新的组件反而会更新了
   9. 父 Subscription -> 子 Subscription 这种模式，可以逐层管理 connect 的状态派发，不会因为 state 的改变而导致更新的混乱。

1. connect控制更新
   1.  核心：

   2. connect 中有一个 selector 的概念，通过 mapStateToProps ，mapDispatchToProps ，把 redux 中 state 状态合并到 props 中，得到最新的 props 。
   3. 每一个 connect 都会产生一个新的 Subscription ，和父级订阅器建立起关联，这样父级会触发子代的 Subscription 来实现逐层的状态派发。
   4. Subscription 通知的是 checkForUpdates 函数，checkForUpdates 会形成新的 props ，与之前缓存的 props 进行浅比较，如果不想等，那么说明 state 已经变化了，直接触发一个useReducer 来更新组件，上述代码片段中，我用 useState 代替 useReducer 了，如果相等，那么当前组件不需要更新，直接通知子代 Subscription ，检查子代 Subscription 是否更新，完成整个流程。

## 组件强化方式

1.  类组件继承
   1.  优势：

   2. 可以控制父类render，还可以添加一些其他的渲染内容
   3. 可以共享父类方法，还可以添加额外的方法和属性

但是state和生命周期会被继承后的组件修改

1. 函数组件自定义hooks

1. HOC高阶组件

## setState

1. 触发setState发生了什么
   1.  **如果调用setState 方法，实际上是 React 底层调用 Updater 对象上的 enqueueSetState 方法。**

   2. > enqueneSetState方法：类组件初始化过程中绑定了负责更新的`Updater`对象。enqueneSetState创建了一个update，然后放入当fiber对象的待更新队列中，最后开启调度更新，进入更新流程

   3. setState会产生当前更新的优先级（老版本用expirationtime,新版本用lane）
   4. react会从fiber root根部向下调和子节点，调和阶段将对比发生更新的地方，更新对比expirationTime，找到发生更新的组件，合并state，然后触发render函数得到新的UI视图层，完成render阶段
   5. 在commit阶段中，替换真实DOM，完成此次更新流程
   6. 仍在commit阶段，会执行setState中callback函数，到此为止完成了一次setState全程
   7. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJjMzIzZGI5MDhhOTA1Y2Q4MmQ2ZGYzYTAyMDgxODNfQVVqYVdFUXIweWJzNGd2aUhBNEFVbzdxUkcwY2ozZnpfVG9rZW46Ym94Y25Vd3h6eWZ4VHdZdER4MFkzTExxTElnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 类组件如何限制state视图？
   1. pureComponent可以对state和props进行浅比较，如果没有发生变化，那么组件不更新
   2. shouldComponentUpdate生命周期可以通过判断前后state变化来决定组件需不需要更新，需要更新返回true，否则返回false

1. 类组件中的setState和函数组件中的useState有什么异同？
   1.  相同点：

   2. setState和useState()更新视图，底层都调用了scheduleUpdateOnFiber方法，而且事件驱动情况下都有批量更新规则
   3.  不同点；

   4. 在不是 pureComponent 组件模式下， setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 **useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。**
   5. setState 有专门监听 state 变化的回调函数 callback，可以获取最新state；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。

1. 为函数绑定组件实例
   1.  在react类组件中，当我们把事件处理函数引用作为回调传递过去，事件处理程序方法会丢失其隐式绑定的上下文，当事件被触发并且处理程序被调用时，this的值会会推到默认绑定，即使值为undefined

   2.  所有在类中定义的方法都默认开启局部严格模式，所以在Class组件当中

   3. **所以指向window对象的this都指向undefined**
   4. **所有内联的的事件处理处理函数当中的this都指向undefined**
   5. 在构造函数中绑定
      1. ```JavaScript
         class Foo extends Component {
             constructor(props) {
                 super(props);
                 this.handleClick = this.handleClick.bind(this);
             }
             handleClick() {
                 console.log('Click happened');
             }
             render() {
                 return <button onClick={this.handleClick}>Click Me</button>;
             }
         }
         ```
   6. 在render中的绑定
      1. ```JavaScript
         class Foo extends Component {
             handleClick() {
                 console.log('Click happened');
             }
             render() {
                 return <button onClick={this.handleClick.bind(this)}>Click Me</button>;
             }
         }
         ```
   7. class 属性（第三阶段提案）
      1. ```JavaScript
         class Foo extends Component {
             // Note: this syntax is experimental and not standardized yet.
             handleClick = () => {
                 console.log('Click happened');
             }
             render() {
                 return <button onClick={this.handleClick}>Click Me</button>;
             }
         }
         ```
   8. 在render中的绑定
      1. ```JavaScript
         class Foo extends Component {
             handleClick() {
                 console.log('Click happened');
             }
             render() {
                 return <button onClick={()=>this.handleClick()}>Click Me</button>;
             }
         }
         ```

1. 给setState传递一个对象与传递一个函数的区别是什么？
   1.  传递一个函数可以让你在函数内访问到当前的 state 的值。因为 `setState` 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突

   2. ```JavaScript
      // 给setState传递一个对象
      incrementCount() {
      // 注意：这样 *不会* 像预期的那样工作。
          this.setState({
              count: this.state.count + 1
          });
      }
      handleSomething() {
      // 假设 `this.state.count` 从 0 开始。
          this.incrementCount();
          this.incrementCount();
          this.incrementCount();
          // 当 React 重新渲染该组件时，`this.state.count` 会变为 1，而不是你期望的 3。
          // 这是因为上面的 `incrementCount()` 函数是从 `this.state.count` 中读取数据的，
          // 但是 React 不会更新 `this.state.count`，直到该组件被重新渲染。
          // 所以最终 `incrementCount()` 每次读取 `this.state.count` 的值都是 0，并将它设为 1。
      }
      // 给setState传递一个函数
      incrementCount() {
          this.setState((state) => {
              // 重要：在更新的时候读取 `state`，而不是 `this.state`。
              return {count: state.count + 1}
          });
      }
      handleSomething() {
      // 假设 `this.state.count` 从 0 开始。
          this.incrementCount();
          this.incrementCount();
          this.incrementCount();
          // 如果你现在在这里读取 `this.state.count`，它还是会为 0。
          // 但是，当 React 重新渲染该组件时，它会变为 3。
      }
      ```

1. setState什么时候是异步的？为什么不同步更新this.state?
   1.  如果 `Parent` 和 `Child` 在同一个 click 事件中都调用了 `setState` ，这样就可以确保 `Child` 不会被重新渲染两次。取而代之的是，React 会将该 state “冲洗” 到浏览器事件结束的时候，再统一地进行更新。这种机制可以在大型应用中得到很好的性能提升。在开始重新渲染之前，React 会有意地进行“等待”，直到所有在组件的事件处理函数内调用的 `setState()` 完成之后。这样可以通过避免不必要的重新渲染来提升性能。

   2.  为什么 React 不能立即更新 `this.state`，而不对组件进行重新渲染呢。

   3.  主要有两个原因：

   4. 这样会破坏掉 `props` 和 `state` 之间的一致性，造成一些难以 debug 的问题。
   5. 这样会让一些我们正在实现的新功能变得无法实现。

## 生命周期

react在调和（render）阶段会深度遍历ReactFiber树，目的就是发现不同（diff），不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行render函数，在一次调和过程完毕之后，就到了commit阶段，commit阶段会创建修改真实的dom节点

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY5ZTFkZmNjZTZjNDg5YWJhNzVkODk1MmEyMGY1YWFfQ0RxUDVLUjdISEVkYjl6cWpPcjFRcXRObnNzY0M5U1RfVG9rZW46Ym94Y25Gd3N5ekg2dXB1dkVVYUV3aXlJRkVjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 初始化阶段：
   1.  constructor=>getDerivedStateFromProps/componentWillMount=>render=>componentDidMount

   2. construtor执行：首先执行的constructClassInstance函数，用来市里话React组件
   3.  getDerivedStateFromProps 执行：它是从constructor类上直接绑定的静态方法，传入props，state，返回值返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。
   4. componentWillMount执行：如果存在 `getDerivedStateFromProps` 和 `getSnapshotBeforeUpdate` 就不会执行生命周期`componentWillMount`。
   5. render执行：到此为止，mountClassInstancec组件初始化完成，但是updateClassComponent在执行完mountClassInstancec后，执行了render渲染函数，形成了children，**接下来react调用reconcileChildren 方法深度调和 children**
   6. componentDidMount执行：一旦React调和完所有的fiber节点，就会到commit阶段，在组件初始化commit阶段，会调用该生命周期

1. 更新阶段：
   1.  componentWillReceiveProps( props 改变) / getDerivedStateFromProp -> shouldComponentUpdate -> componentWillUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate

   2. 执行生命周期componentWillReceiveProps：首先判断getDerivedStateFromProps生命周期是否存在，如果不存在就执行该生命周期，传入该生命周期两个参数，分别是 newProps 和 nextContext 。
   3. 执行生命周期getDerivedStateFromProps，返回的值用于合并state，生成新的state
   4. 执行生命周期shouldComponentUpdate：传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，`getDerivedStateFromProps` 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。
   5. 执行生命周期componentWillUpdate：updateClassInstance 方法到此执行完毕了
   6. 执行render函数，得到最新的reactelement元素，然后继续调和子节点
   7. 执行 getSnapshotBeforeUpdate：发生在commit阶段中的before Mutation阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。
   8. 执行componentDidUpdate：此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕

1. 销毁阶段：
   1. 执行生命周期 componentWillUnmount：在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 `componentWillUnmount` 生命周期，接下来统一卸载组件以及 DOM 元素。

- 在componentDidUpdate()中直接调用setState时，需要将其包裹在一个条件语句里面

- `componentWillUnmount()` 中**不应调用** **`setState()`**，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。

### 生命周期作用

1. constructor：在该阶段进行初始化的工作
   1. 初始化state，比如可以用来截取路由中的参数，赋值给 state 
   2. 对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。
   3. 对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。

1. getDerivedStateFromProps(nextProps,prevState):
   1. 两个参数：
      1. nextProps 父组件新传递的 props ;
      2. prevState 传入 getDerivedStateFromProps 待合并的 state 。
   2. 作为类的静态属性方法执行，内部是访问不到this的，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。
   3. 作用：
      1. 代替 componentWillMount 和 componentWillReceiveProps
      2. 组件初始化或者更新时，将 props 映射到 state。
      3. 返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数 newState ，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和

1. componentWillMount 和 UNSAFE_componentWillMount
   1.  为什么添加不安全的标识符？

   2.  componentWillMount ，componentWillReceiveProps ， componentWillUpdate三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。

1. componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps
   1.  在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。

   2. componentWillReceiveProps 可以用来监听父组件是否执行 render 。
   3. componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新 state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是 getDerivedStateFromProps 不能实现的。
   4. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg2MTU5YTU3NzBhNzI1MzM0ZTc1ODdmMDBiOWJmMDRfeXNobVAyV2x1Y3NNRWhqMzQ1VXlBdTNPeU5CeU5STU1fVG9rZW46Ym94Y25GMDRDUERXekF2b1dMWGlzMkhSMExtXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   5.  当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？

   6.  componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。

   7. 

1. componentWillUpdate 和 UNSAFE_componentWillUpdate
   1.  在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。

1. render： jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。

1. getSnapshotBeforeUpdate(prevProps,preState)
   1. 两个参数：
      1. prevProps更新前的props ；
      2. preState更新前的state；
   2. 该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个`snapShot`(快照)，传递给 componentDidUpdate作为第三个参数。

1. componentDidUpdate(prevProps, prevState, snapshot)
   1. 三个参数：
      1. prevProps 更新之前的 props ；
      2. prevState 更新之前的 state ；
      3. snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。
   2. 作用：
      1. componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。
      2. 接受 getSnapshotBeforeUpdate 保存的快照信息。

1. componentDidMount：此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。
   1.  作用：

   2. 可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。
   3. 对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。

1. shouldComponentUpdate(newProps,newState,nextContext)
   1. 三个参数：
      1. 第一个参数新的 props 
      2. 第二个参数新的 state 
      3. 第三个参数新的 context 。
   2. 作用：
      1.   一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用。

1. componentWillUnmount：组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。
   1.  作用：

   2. 清除延时器，定时器。
   3. 一些基于 DOM 的操作，比如事件监听器。

### 函数组件生命周期替代方案

**主要是运用了 hooks 里面的** **`useEffect`** **和** **`useLayoutEffect`****。**

1. **useEffect和useLayoutEffect**
   1.  **一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。**

   2. useEffect：对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 `setTimeout`回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。
   3. useLayoutEffect：
      - 首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。
      - useLayoutEffect callback 中代码执行会阻塞浏览器绘制。

1. useInsertionEffect：useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。
   1.  在 useLayoutEffect之前执行，主要是解决[ CSS-in-JS ](https://developer.aliyun.com/article/781882)在渲染中注入样式的性能问题，在useInsertionEffect中使用css-in-js避免了浏览器再次出现重绘和重排的kennel。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 

   2.  如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？

   3. 首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。
   4. 如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。

1. componentDidMount替代方案
   1. ```JavaScript
      React.useEffect(()=>{
          /* 请求数据 ， 事件监听 ， 操纵dom */
      },[])  /* 切记 dep = [] */
      ```

1. componentWillUnmount 替代方案
   1. ```JavaScript
       React.useEffect(()=>{
              /* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */
              return function componentWillUnmount(){
                  /* 解除事件监听器 ，清除定时器，延时器 */
              }
      },[])/* 切记 dep = [] */
      ```

1. componentWillReceiveProps 代替方案
   1.  说 useEffect 代替 componentWillReceiveProps 着实有点牵强。

   2. 首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。
   3. 其次 **useEffect 会初始化执行一次**，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。

1. componentDidUpdate 替代方案
   1.  useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。

   2. ```JavaScript
      React.useEffect(()=>{
          console.log('组件更新完成：componentDidUpdate ')     
      }) /* 没有 dep 依赖项 */
      ```

## Ref

### 基本概念和使用

1. ref对象创建
   1.  ref 对象就是用 `createRef` 或者 `useRef` 创建出来的对象，一个标准的 ref 对象应该是如下的样子

   2. ```JavaScript
      {
          // current指向ref对象获取到的实际内容，可以是dom元素，组件实例，或者其它。
          current:null , 
      }
      ```

   3. 类组件React.createRef
      - ```JavaScript
        class Index extends React.Component{
            constructor(props){
               super(props)
               this.currentDom = React.createRef(null)
            }
            componentDidMount(){
                console.log(this.currentDom)
            }
            render= () => <div ref={ this.currentDom } >ref对象模式获取元素或组件</div>
        }
        ```
   4. 函数组件useRef
      - ```JavaScript
        export default function Index(){
            const currentDom = React.useRef(null)
            React.useEffect(()=>{
                console.log( currentDom.current ) // div
            },[])
            return  <div ref={ currentDom } >ref对象模式获取元素或组件</div>
        }
        ```

      -   hooks 和函数组件对应的 fiber 对象建立起关联，将 useRef 产生的 ref 对象挂到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数组件对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来。
   5.  为什么在函数组件中不能使用createRef？

   6.   类组件有一个实例 instance 能够维护像 ref 这种信息，但是由于函数组件每次更新都是一次新的开始，所有变量重新声明，所以 useRef 不能像 createRef 把 ref 对象直接暴露出去，如果这样每一次函数组件执行就会重新声明 Ref，此时 ref 就会随着函数组件执行被重置

### 类组件获取ref的三种方式

1. ref属性是一个字符串
   1.  用一个字符串 ref 标记一个 DOM 元素，一个类组件(函数组件没有实例，不能被 Ref 标记)。React 在底层逻辑，会判断类型，如果是 DOM 元素，会把真实 DOM 绑定在组件 this.refs (组件实例下的 refs )属性上，如果是类组件，会把子组件的实例绑定在 this.refs 上。

1. ref属性是一个函数
   1.  当用一个函数来标记 Ref 的时候，将作为 callback 形式，等到真实 DOM 创建阶段，执行 callback ，获取的 DOM 元素或组件实例，将以回调函数第一个参数形式传入，所以可以像上述代码片段中，用组件实例下的属性 currentDom和 currentComponentInstance 来接收真实 DOM 和组件实例。

1. ref属性是一个对象

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzVhMWVlYWZlMjU0MDdjYjAzOGExMjc2ODYxYTdmOThfbUdKdHBsTFNDNUxtSG9CQzNaa3FyQ2V1ZnBwWGJUTllfVG9rZW46Ym94Y243ZUV1Y1dWVjlkSnU1cWdyR1BSSlpkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### 高阶用法

1. forwardRef转发ref
   1.  forwardRef 的初衷就是解决 ref 不能跨层级捕获和传递的问题。 forwardRef 接受了父级元素标记的 ref 信息，并把它转发下去，使得子组件可以通过 props 来接受到上一层级或者是更上层级的ref

1. 函数组件 forwardRef + useImperativeHandle

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NGY5NmI5YzVhMTJkZDIzYWJjNzk3OWRlNjY3Y2JlZjJfMEJEZEc3ekhXYzZqVzJhckJ6VmpUNUIxMnFtQVk5WFlfVG9rZW46Ym94Y24yQmtESG9HbFpaVXBrc3dlUUd2cENoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ1MjIxY2E4MTIxY2UzNzQxZTcxODYwOWYwOTk2ZmZfWDYxZWJtZEhGek9uWmNkMFIxNmZERDZTdlpBTVpJZjZfVG9rZW46Ym94Y25paXpLbkplR21uUUdTOGxuRjJNb083XzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- 流程：

- - 父组件用ref标记子组件，由于子组件 Son 是函数组件没有实例，所以用 forwardRef 转发 ref。
  - 子组件 Son 用 useImperativeHandle 接收父组件 ref，将让 input 聚焦的方法 onFocus 和 改变 input 输入框的值的方法 onChangeValue 传递给 ref 。
  - 父组件可以通过调用 ref 下的 onFocus 和 onChangeValue 控制子组件中 input 赋值和聚焦。

1. 函数组件缓存数据
   1.  函数组件每一次 render ，函数上下文会重新执行，那么有一种情况就是，在执行一些事件方法改变数据或者保存新数据的时候，有没有必要更新视图，有没有必要把数据放到 state 中。如果视图层更新不依赖想要改变的数据，那么 state 改变带来的更新效果就是多余的。这时候更新无疑是一种性能上的浪费。

   2.  把一些不依赖于视图更新的数据储存到 ref 对象中。这样做的好处有两个：

   3. 第一个能够直接修改数据，不会造成函数组件冗余的更新作用。
   4. 第二个 useRef 保存数据，如果有 useEffect ，useMemo 引用 ref 对象中的数据，无须将 ref 对象添加成 dep 依赖项，因为 useRef 始终指向一个内存空间，**所以这样一点好处是可以随时访问到变化后的值。**

### ref原理

对于 Ref 处理函数，React 底层用两个方法处理：**commitDetachRef** 和 **commitAttachRef****，**一次在dom更新之前，一次在dom更新之后

1. 第一阶段：一次更新中，在 commit 的 mutation 阶段, 执行commitDetachRef，commitDetachRef 会清空之前ref值，使其重置为 null。 

1. 第二阶段：DOM 更新阶段，这个阶段会根据不同的 effect 标签，真实的操作 DOM 。

1. 第三阶段：layout 阶段，在更新真实元素节点之后，此时需要更新 ref 。主要判断 ref 获取的是组件还是 DOM 元素标签，如果 DOM 元素，就会获取更新之后最新的 DOM 元素。上面流程中讲了三种获取 ref 的方式。 如果是字符串 ref="node" 或是 函数式 ref={(node)=> this.node = node } 会执行 ref 函数，重置新的 ref

`markRef` 会在以下两种情况下给 effectTag 标记 Ref，只有标记了 Ref tag 才会有后续的 `commitAttachRef` 和 `commitDetachRef` 流程。（ current 为当前调和的 fiber 节点 ）

- 第一种` current === null && ref !== null`：就是在 fiber 初始化的时候，第一次 ref 处理的时候，是一定要标记 Ref 的。

- 第二种` current !== null && current.ref !== ref`：就是 fiber 更新的时候，但是 ref 对象的指向变了。

**在 Provider 里 value 的改变，会使引用****`contextType`****,****`useContext`** **消费该 context 的组件重新 render ，同样会使 Consumer 的 children 函数重新执行**

如何阻止provider value改变造成的children不必要的渲染？

1. 利用memo，pureComponent对子组件props进行浅比较处理

1. React 本身对 React element 对象的缓存。React 每次执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新

### context 与 props 和 react-redux 的对比？

context解决了props需要每一层都手动添加props的缺陷，解决了改变value，组件全部重新渲染的缺陷

react-redux 就是通过 Provider 模式把 redux 中的 store 注入到组件中的。

## 高阶组件

#### 属性代理

```JavaScript
function HOC(WrapComponent){
    return class Advance extends React.Component{
       state={
           name:'alien'
       }
       render(){
           return <WrapComponent  { ...this.props } { ...this.state }  />
       }
    }
}
```

优点：

- ① 属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC ，目前开源的 HOC 基本都是通过这个模式实现的。

- ② 同样适用于类组件和函数组件。

- ③ 可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染。

- ④ 可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。

缺点：

- ① 一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。

- ② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。

- ③ 因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。

#### 反向继承

```JavaScript
class Index extends React.Component{
  render(){
    return <div> hello,world  </div>
  }
}
function HOC(Component){
    /* 直接继承需要包装的组件 */
    return class wrapComponent extends Component{ 
        
    }
}
export default HOC(Index) 
```

优点：

- ① 方便获取组件内部状态，比如 state ，props ，生命周期，绑定的事件函数等。

- ② es6继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理。

缺点：

- ① 函数组件无法使用。

- ② 和被包装的组件耦合度高，需要知道被包装的原始组件的内部状态，具体做了些什么？

- ③ 如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount ，当前 componentDidMount 会覆盖上一个 componentDidMount 。这样副作用串联起来，影响很大。

## React-router

1. 单页面应用
   1.  用 React 或者 Vue 构建的应用都是单页面应用，单页面应用是使用一个 html 前提下，一次性加载 js ， css 等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。

1. History，react-router，react-router-dom三者关系

   1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAwNDk0ZDhhMTE0NjJiYmNjZjE0OWE3YjYyYjc4NjFfMjFIdFhXZEVpQ3p6bVZodUN3bXBCcTFoejFqeEh6NURfVG9rZW46Ym94Y25CV1htcGxMY2hYM0JsN3MyOGVLcU1lXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   2. - history：history 是整个 React-router 的核心，里面包括两种路由模式下改变路由的方法，和监听路由变化方法等。

   3. - react-router：既然有了 history 路由监听/改变的核心，那么需要调度组件负责派发这些路由的更新，也需要容器组件通过路由更新，来渲染视图。所以说 React-router 在 history 核心基础上，增加了 Router ，Switch ，Route 等组件来处理视图渲染。

   4. - react-router-dom：在 react-router 基础上，增加了一些 UI 层面的拓展比如 Link ，NavLink 。以及两种模式的根部路由 BrowserRouter ，HashRouter 

   5. 

1. 两种路由模式
   1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY2MmViNTllNjdmZWJhYmUyYTBjYzMwMzhiZDRhYWRfUzlqRGhqZzM1RUEwMWdvelg5U1VQd05UOHZkREhiWU5fVG9rZW46Ym94Y25oMVVDUlNGZmkwOXd2dmZlQjY1YmZmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   2. history模式
      -   同一个文档的history对象出现变化时，就会触发popstate事件，history.pushState 可以使浏览器地址改变，但是无需刷新页面

      - > 用 `history.pushState()` 或者 `history.replaceState()` 不会触发 popstate 事件。 popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 `history.back()`、`history.forward()`、`history.go()`方法。

      - ###   为什么pushState()或者replaceState()不触发popState事件的情况下，ReactRouter还能挂在对应路由的组件![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJkZDZiNzM0ZjA1MDU5ZWM1ZjM1ZWE4M2Q0MTIwMDhfOWc5TDlIc2V0bDVjVVpGUUlVTnI1STd2ZWVSRllYcHhfVG9rZW46Ym94Y25nRzFkWTU2dzFvYmRjTTJpRDdrcG9PXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ1YjdlNTEyN2NjMWVkNTQ5ZGVhNTBjODhhODhmMzNfZlVxTWVxS0NEQkpXVWJkS3RnZVl2ZldEdmlGUGxJcDlfVG9rZW46Ym94Y254cE1FZHRjRzR0MjVpUk1kb29LSHloXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
   3. hashHistory模式
      - 通过 `window.location.hash` 属性获取和设置 hash 值。开发者在哈希路由模式下的应用中，切换路由，本质上是改变 `window.location.hash`
      - 监听路由：onHashchange，hash路由模式下，监听路由变化用的是hashchange

1. Router组件
   1. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MmYwMTEyMDA2ZDU0MDIxMDk0NWZiYTU3YzA4ZDIzOGFfeFJRRzRIa0xlTnJRcVNiVmNrdEp3T2ZodFI1WWxTVE9fVG9rZW46Ym94Y25qUzRxUTR0RTVLWTA1bmRtWkI2RlJkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVkODViYzg2YmJhYmYwNjEzNmY1MmZjMWM4ZTI3ZWVfYXA1cFFzbUJLRXdoMW5VbmFJZ0lCQ2w2M3lScEtvNjZfVG9rZW46Ym94Y25pY2pob2pZUlA1SnRsZFpEZFQxaTVlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   2. 

   3. react-router是通过context上下文方式传递的路由信息，context 改变，会使消费 context 组件更新，这就能合理解释了，当开发者触发路由改变，为什么能够重新渲染匹配组件
   4. props.history是通过BrowserRouter或HashRouter创建的history对象，并传递过来的，当路由改变，会触发listen方法，传递新生成的location，然后通过setState来改变context中的value，所以改变路由，本质上是location改变带来的更新作用

1. Route组件

   1.  用于匹配路由，路由匹配，渲染组件

   2. 四种Route编写格式：

      - component形式：将组件直接传递给 Route 的 component 属性，Route 可以将路由信息隐式注入到页面组件的 props 中，但是无法传递父组件中的信息，比如如上 mes
      - render形式：Route 组件的 render 属性，可以接受一个渲染函数，函数参数就是路由信息，可以传递给页面组件，还可以混入父组件信息
      - children形式：直接作为 children 属性来渲染子组件，但是这样无法直接向子组件传递路由信息，但是可以混入父组件信息
      - renderProps形式：可以将 childen 作为渲染函数执行，可以传递路由信息，也可以传递父组件信息。
      - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE3NmM1OGYxNmI5NjU4ODhlYTlhZjBlMzkzOGUyOTJfWENuT2VsS3FMa094ZWtYM0pnZ3BMN1dENXFBdEM4T25fVG9rZW46Ym94Y25LM25GMUVsWmxxd0pOZmZrem9RVjFpXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   3. - 我们可以使用react-router-config库中提供的renderRoutes更优雅的渲染Route

   4. 

   5. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI4MjQ4YWIzOGE1YmYwNTRlNmNhNjJiYzk1MTdlMGZfVEtZb3NBamI3R0tmVU9nVEJyNWlOamdPWTlqSEhsbzRfVG9rZW46Ym94Y25mOGxlME1WUUtmbVZuVmJkcUc2Qm1iXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   6. 

1. 路由带参数跳转
   1. 路由跳转有声明式路由和函数式路由两种
      1. 声明式：<NavLink to='/home' /> ，利用 react-router-dom 里面的 Link 或者 NavLink 
      2. 函数式：histor.push('/home')

## 事件原理

[面试官:说说React的事件机制? | web前端面试 - 面试官系列](https://vue3js.cn/interview/React/SyntheticEvent.html#一、是什么)

- ### React 为什么有自己的事件系统？ 

- -  对于不同的浏览器对事件存在不同的兼容性，react想实现一个兼容全浏览器的框架，为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异

  -  v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获-> 事件源 -> 事件冒泡，也包括重写一下事件源对象 event 

- ### 阻止默认行为

- -  原生事件：e.preventDefault() 和 return false 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。所以导致 return false 方法在 React 应用中完全失去了作用。

  -  react事件：在React应用中，可以用 e.preventDefault() 阻止事件默认行为，这个方法并非是原生事件的 preventDefault ，由于 React 事件源 e 也是独立组建的，所以 preventDefault 也是单独处理的。

- ### 什么是事件合成 ？ 

- -  react事件系统可以分为三个部分：

  - 事件合成系统，初始化会注册不同的事件插件
  - 在一次渲染过程中，对事件标签中事件的收集，向container注册事件
  - 一次用户交互，事件触发，到事件执行一系列过程
  -  事件合成：React应用中，元素绑定的事件并不是原生事件，而是React合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。

- ### 事件插件机制

- -  React有一种事件插件机制，针对不同的事件，会有不同的事件插件处理

  - **registrationNameModules** ：记录了React事件和与之对应的处理插件的映射
  - registrationNameDependencies：保留了React事件与原生事件对应关系，在事件绑定阶段，如果发现有react事件，比如onChange就会找到对应的原生事件数组，逐一绑定

- ### 事件绑定

- -  **流程：**

  - **将事件保存在对应DOM元素类型fiber对象****上的memorizedProps**
  - **判断在registrationnameModules中当前的props是否存在于memorizedProps中，如果存在就从regitrationNameDependencies中获取到对应事件依赖的原生事件数组并进行绑定**
  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjAzZTkyYmUwOWQ2Y2Y5ZWZjMDg3YjRlYTkxNWZjMjVfWWM5UTZ3ejF5MHhnQ0pOTURXMFNjRTBxamllSUJwWW5fVG9rZW46Ym94Y255Z20zRmxBOHNKOFhkQTZ6NzJnZEtlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

  - 给元素绑定的事件，最后去了哪里？（比如onClick={handleChange}）
    -   答：会都保存在对用Dom元素类型fiber对象的memorizedProps属性上

    - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YmYwOTY4OWI2YjgzOWY0NDJhOGU5MDNhZWUzZWE4ODdfQ3lkUWs2NjRaV3NJWUxrVGxYcFZaTEJiakFZNmlDZFBfVG9rZW46Ym94Y25VUTNTVFlvYlgxUjJxT0NEdmpuMEZmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
  - React根据事件注册事件监听器
    -   listener函数监听函数将原生事件派发到react体系之内（*比如点击 DOM 触发原生事件, 原生事件最后会被派发到react内部的onClick函数*.）listener函数是通过createEventListenerWrapperWithPriority函数产生的，会对不同的事件赋予对应的优先级

    - DiscreateEvent：优先级最高，包括click，keyDown，input等事件
    - UserBlockingEvent：优先级适中，包括drag，scroll等事件
    - ContinousEvent：优先级最低，包括animation，load等事件
    - ```JavaScript
      function diffProperties(){
          /* 判断当前的 propKey 是不是 React合成事件 */
          if(registrationNameModules.hasOwnProperty(propKey)){
               /* 这里多个函数简化了，
                  如果是合成事件， 传入成事件名称 onClick 
                  向document注册事件  */
               legacyListenToEvent(registrationName, document）;
          }
      }
      function legacyListenToEvent(registrationName，mountAt){
      // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。
         const dependencies = registrationNameDependencies[registrationName]; 
          for (let i = 0; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          //  addEventListener 绑定事件监听器
          ...
        }
      }
      ```

- ### 事件触发（以一次点击事件为例）

- - > 事件触发总体分为三步：
    >
    > 1. 监听原生事件：对齐DOM元素和fiber元素
    >
    > 1. 收集listeners：遍历fiber树，收集所有监听本事件的listener函数
    >
    > 1. 派发合成事件：构造合成事件，遍历listeners进行派发

  - 批量更新

    1.   React在初始化真实DOM的时候，用一个随机的key internalInstanceKey指针指向了当前 DOM 对应的 fiber 对象，fiber 对象用 stateNode 指向了当前的 DOM 元素。批量更新

    2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NzRmMjhkMmE4YThmYjQyMjYxM2M5Mjg0YjZkNjVkZWVfTmpsUUlmVERBT1NkYThTOUVaVFJta25zUEhYY0V4SlhfVG9rZW46Ym94Y244bXhHNGdlTEdBUHYyR3RNaDF4OFljXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

  - 合成事件源

    1.   通过onClick找到对应的处理插件SimpleEventPlugin，合成新的事件源e，里面包含新的事件源e，里面包含preventDefault和stopPropagation等方法。

  - 形成事件执行队列

    1.   批量更新时，原生 DOM 获取到对应的 fiber ，接着会从这个 fiber 向上遍历，遇到元素类型 fiber ，就会收集事件，用一个数组收集事件

    2. 如果遇到捕获阶段事件 onClickCapture ，就会 unshift 放在数组前面。以此模拟事件捕获阶段。
    3. 如果遇到冒泡阶段事件 onClick ，就会 push 到数组后面，模拟事件冒泡阶段。
    4. 一直收集到最顶端 app ，形成执行队列，在接下来阶段，依次执行队列里面的函数。

### React 如何模拟组织事件冒泡

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NWE4MzRjNTI1NTU4MzczZmJhY2UyNjMzMzhhYWRjZWJfZ2NxRlZmSkZZNmpDSlozVVJpOFpoNmIyeDhVSFJQR21fVG9rZW46Ym94Y25TM1l0aDBKdFlpOEROQ2xoNFpmSDlnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- 所以会先执行原生事件，然后处理 React 事件

- 最后真正执行 document 上挂载的事件

## 调度

- ### 为什么采用异步调度

- -  `v15` 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡

  - > 与vue框架对比：
    >
    > vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同

### 时间分片

浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。

谷歌浏览器中，提供了requestIdleCallback Api，在浏览器有空余的时间，浏览器就会调用requestIdleCallback 的回调

```JavaScript
requestIdleCallback(callback,{timeout})
callback: 回调，浏览器空余时间执行回调函数
timeout: 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，
         为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间
```

React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级

- `Immediate` -1 需要**立刻执行**。

- `UserBlocking` 250ms 超时时间250ms，一般指的是**用户交互**。

- `Normal` 5000ms 超时时间5s，不需要直观立即变化的任务，比如**网络请求**。

- `Low` 10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。

- `Idle` 一些没有必要的任务，可能不会执行。

**React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。**

### 模拟requestIdleCallback

由于目前只有google支持，为了兼容其他浏览器，react需要手动实现，其中重要的两点：（宏任务）

- 实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。

- 一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。

两种方案：

1. setTimeout(fn,0)
   1.  不使用该种方式的原因：递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案

   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVhYzkyM2Y4ZDBmOTBjNzdhNTExM2FmNzA0ZDllZjhfNGg3bEs0RERHMUV0bGhBNlR1cVBRSkVrclIxSVBOd05fVG9rZW46Ym94Y25walk5NU50WDdoSG1pRzZQSTZ5ZnpnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. MessageChannel
   1.  该接口允许开发者创建一个新的消息通道，并通过他的两个MessagePort属性发送数据

   2. MessageChannel.port1 只读返回 channel 的 port1 。
   3. MessageChannel.port2 只读返回 channel 的 port2 。
   4.  在一次更新中，React会调用requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。

   5.  port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。

   6. ```JavaScript
      let scheduledHostCallback = null 
        /* 建立一个消息通道 */
        var channel = new MessageChannel();
        /* 建立一个port发送消息 */
        var port = channel.port2;
      
        channel.port1.onmessage = function(){
            /* 执行任务 */
            scheduledHostCallback() 
            /* 执行完毕，清空任务 */
            scheduledHostCallback = null
        };
        /* 向浏览器请求执行更新任务 */
        requestHostCallback = function (callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            port.postMessage(null);
          }
        };
      ```

### 异步调度原理

React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。

- 对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 workLoopSync 。

- 对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 workLoopConcurrent 。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE3MDQ2ZjBmMDEwNWZjM2ExYWRhNDliODAxYzVhMjZfM0xrZE1rOFFGWVhwQ0lidnNsd3JZWTBiRUtYWE1ScmpfVG9rZW46Ym94Y25zb2hrU1FGMkhZNDZObHB1YVR2VW9oXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。

### 调度器scheduleCallback

无论是上述正常更新任务 `workLoopSync` 还是低优先级的任务 `workLoopConcurrent` ，都是由调度器 `scheduleCallback` 统一调度的

- taskQuene：里面存的都是过期的任务，依据任务的过期时间( `expirationTime` ) 排序，需要在调度的 `workLoop` 中循环执行完这些任务。

- timerQuene：里面存的都是没有过期的任务，依据任务的开始时间( `startTime` )排序，在调度 workLoop 中 会用`advanceTimers`检查任务是否过期，如果过期了，放入 `taskQueue` 队列。

scheduleCallback流程：

1. 创建一个新的任务newTask

1. 通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime > currentTime, 说明未过期, 存到 timerQueue，当 startTime <= currentTime, 说明已过期, 存到 taskQueue。

1. 如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。

1. 如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YjYyMjJkMzFlOTBhZWYxYWY5ZjJmZmUyNjk2NTY5NDBfWTQ1QVNmaDMzRGdKQ1lwMm0yQVNBbGxRelNiOHNHRW5fVG9rZW46Ym94Y25jcHFLV3l4QmNVSDJ0R3k4ZTRRUEhBXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

**requestHostTimeout**

让一个未过期的任务恰好能够达到过期的状态，那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiNDBjZDQzYjM5NThlMzk1ODhiOTc0MzNkYzBkMThfVXJWbk5WaUQyRHBabVNhdTZQTDlhMHpkc2laUlpJYUxfVG9rZW46Ym94Y240QzdwT01VWlkwZHBPMWpmTFlHS3dmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

**handleTimeout**

延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ODY4NjY2NzNjMjA3MTNkMjg2ZWFkYzJhOTMwODYyMDlfY1FYVm44NVBCOVNSUjlDWEdhWGRPd1hTZEw0RGhJMWJfVG9rZW46Ym94Y250Ukt2UUI3c25rUUw5Y29FakxaOUJnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- 通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。

- 然后调用 requestHostCallback 调度过期的任务。

**advanceTimers**

- 如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg5NTE3MDdkMThlMDVkZDc0Y2E2MGQ1ODM4NGRlMmJfeVIxSzVzM3pQb0x1N2ZUTGJFUlB2UHByQktpcVIxMHdfVG9rZW46Ym94Y25Ic2hjZlpwbUZ4Nk9kVHNhNmxHU21nXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

React更新任务最后都是放在taskQuene中的

requestHostcallback，放入MessageChannel 中的回调函数是flushWork。

**flushWork**

- flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NWIwMjVhNjU1ZWU1MzU3ZGMzMTdmYWRiODQ2YjUwM2VfN2hvWURMWDJHWkNLc09jb2dkWGhZZGIwbWJMRDVqZ21fVG9rZW46Ym94Y25WYnRZc1lGWlZUUThBNGFoMXRUWENmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

**workLoop**

会依次更新过期任务队列中的任务

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMzNGM4NmEzNjkyNDA0OTUyMzFkMzAxY2EzZDg5NjZfVWlOVWRDSTdIUzZJRWtOeHJUWGFvR0FkZ3JkNUhtQkNfVG9rZW46Ym94Y253VllmSmJxZVJXVlo4UGFLY20yMmlnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 调和&Fiber

### Fiber

#### 为什么要用fiber

在 `Reactv15` 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互上的体验就是卡顿。

`Reactv16` 为了解决卡顿问题引入了 fiber ，为什么它能解决卡顿，更新 fiber 的过程叫做 `Reconciler`（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间`expirationTime`（ v17 版本叫做优先级 `lane` ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 `scheduler` （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。

#### React.Element，fiber，dom三者的关系

- **element 是 React 视图层在代码层级上的表象**，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props ， children 等信息。

- **DOM 是元素在浏览器上给用户直观的表象。**

- **fiber 可以说是是 element 和真实 DOM 之间的交流枢纽站**，一方面每一个类型 element 都会有一个与之对应的 fiber 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDBhYjQ4MmRmYTBiMDdiYWI2Y2JmZDdkZTZmOGI2NTZfcUxha3hVa1A4eXR4MEowOENwVHROQjlEZmlLZ2swQlFfVG9rZW46Ym94Y25BNVZmNnA5RUZaREczMXpDUElwN1hjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YThkM2RhYzAyZjU1NmI0NGUxM2Y1NTRjOWU2ODRiN2FfRzNrYzl3UHBCaDczU0xqMXJWbTZXa09hSjIyVXpNZWJfVG9rZW46Ym94Y242TlcwVHBlamVRTDNIYzU3Qk5Tcm1nXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

#### fiber保存的信息

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM5NzQ3M2JjODI0ODJiYjk1OGE2MTVjZTU2NTg5ZmNfaWF4RjlVQ2hkM1ZVNHpDUk1NWnJidXJNTnpKRUQ3Q2lfVG9rZW46Ym94Y242emhNbXVhbnFMSnp3b1RLMGlQZ3diXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

#### fiber之间怎么建立联系的

每一个 fiber 是通过 return ， child ，sibling 三个属性建立起联系的。

- return： 指向父级 Fiber 节点。

- child： 指向子 Fiber 节点。

- sibling：指向兄弟 fiber 节点。

#### fiber更新机制

alternate：双缓存树，指向缓存的fiber，更新阶段，两棵树互相交替

workInProgress ：正在内存中构建的fiebr树

**创建fiebrRoot和rootfiber，进入rootFiber的渲染流程，首先复用当前的current（rootFiber）树，如果没有alternate，就创建一个fiber作为workInProgress ，会用alternate将新创建的workInProgress 与current树建立起关联，在新创建的双缓冲树上，完成整个fiber树的遍历，最后将workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树**

1. 初始化
   1. 创建fiberRoot和rootFiber，第一次挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。
      1.   fiberRoot：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。

      2.   rootFiber：如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。

      3. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMyYWZiNTU4OTMxN2NlNTE3Y2IxZDNkOGZmNzU1M2ZfakpaTXB2c2VwZmRNdG5RMFNkSkpacnpGRUZhU0ROMEpfVG9rZW46Ym94Y242UlVhOWtja1M0RjJvc2Z3RlFCSHpkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
   2. workInProgress和current
      1.   workInProgress：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图

      2.   current：正在视图层渲染的树叫做curent树

      3.   **rootFiber的渲染流程：**

      4.   首先会复用当前 current 树（ rootFiber ）的 `alternate` 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行

      5. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE3NmQxNWQwOTc1YTM5NTBhN2M2ZmU5NGRjNmE0YzFfU2JmS1BZRkdsSGl3eGFOVFU1TnJaME81cml6TmtIOVpfVG9rZW46Ym94Y25xc1VtcUZGUm5CbGdsTENCWExqNFNoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
   3. 深度调和子节点，渲染视图
      1.   按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。

      2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNmYTJkNmM0NDIxZmY4M2MzMGFlOTA1MzViZTQ4ZWRfY3pONEY4cTNSNkl5eE9FdkJxZWJJajV1Zkx3dW16WjRfVG9rZW46Ym94Y25DN2I0TmZLVFJPN3hRZHkzSFNsbXVjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
   4.  最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。

   5. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=M2JhNWE3ZmU4MjU2ZDdiMjY2MTMzNGM1NzA1ZjBkM2RfZHJCbUw0dHRKWGlkMjJJeW50bnRpNlZaTGo2YzFqd3RfVG9rZW46Ym94Y251VHdWcFZqbHVhcTdvRFBqNlkxRHhlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 更新
   1.  首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树。

   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NTNiZDExMWVmYjllMDhjZDc5ZTFmZGQ0MWZlYmEyZTFfZ1p1b1o3bUtPbG90blp2ek5WOWxoU0U4T1ZvWGFsS0ZfVG9rZW46Ym94Y25lbTR1cnY0TUJVWWxGR2tXandXeGxkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### 双缓冲树

canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做**双缓存**。

React 用 workInProgress 树(内存中构建的树) 和 current (渲染树) 来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。

### 两大阶段

1. render阶段，向下调和向上归并
   1.  每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress 。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。 performUnitOfWork 包括两个阶段 beginWork 和 completeWork 

   2. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NjY0Y2IxYzNkYTU4NTI0ODlhMjFiZjYwYWY1ZDVmNGJfcUNTaU9pZkZTNnRQRnhXNlkwVGdMYnJNbUtnT0I2d3NfVG9rZW46Ym94Y25OVWdTTlRtNHdiZGtGSjRMdG81a0lkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   3. beginWork：向下调和的过程，就是由fiberRoot按照child指针逐层向下调和，期间会执行函数组件，实例类组件，diff调和子节点，打不同effectTag
      - 对于组件，执行部分生命周期，执行 render ，得到最新的 children 
      - 向下遍历调和 children ，复用 oldFiber ( diff 算法)
      - 打不同的副作用标签 effectTag ，比如类组件的生命周期，或者元素的增加，删除，更新。
      -   reconcileChildren——react调和子节点

      - ```JavaScript
        // react-reconciler/src/ReactFiberBeginWork.js
        function reconcileChildren(current,workInProgress){
           if(current === null){  /* 初始化子代fiber  */
                workInProgress.child = mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime)
           }else{  /* 更新流程，diff children将在这里进行。 */
                workInProgress.child = reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime)
           }
        }
        ```
   4. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVjZjViZDkzOTJjYWY0MmVkOWUwYzM3NmVlZGY0MzhfUExJS1VNWkZZak1nMUtHSFVrMER5OENqR3F5ZnZKUGhfVG9rZW46Ym94Y25lN3lBYzNMcHVYNFVXUER4cWd4ZWVkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

   5. completeUnitOfWork：是向上归并的过程，如果有兄弟节点，会返回sibling兄弟，没有返回return父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。
      - 首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的**单向链表**中。在 commit 阶段，将不再需要遍历每一个 fiber ，只需要执行更新 effectList 就可以了。
      - completeWork 阶段对于组件处理 context ；对于元素标签初始化，会创建真实 DOM ，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props ，比如事件收集，style，className 处理

1. commit阶段：执行effectList，更新DOM，执行生命周期，获取ref等操作。
   1. 对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；
   2. 在一次更新中，添加节点（ `Placement` ），更新节点（ `Update` ），删除节点（ `Deletion` ），还有就是一些细节的处理，比如 ref 的处理。
   3.  commit可以细分为：

   4. Before mutation阶段（执行Dom操作前）
      - 因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。
      - 会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。
   5. mutation阶段：执行Dom操作
      - 置空 ref 
      - 对新增元素，更新元素，删除元素。进行真实的 DOM 操作。
   6. layout阶段：执行Dom操作后
      - commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。
      - 如果有 ref ，会重新赋值 ref 。

## legacy模式下调度任务是如何衔接的

1. 初始化流程
   1.  legacy模式是从reactDOM.render开始的，**初始化的更新会直接进入调和阶段同步更新，而不会放入到调度任务中**。reactDOM.render本质上是legacyRenderSubtreeIntoContainer方法，这个方法作用：

   2. 创建整个应用的FiberRoot
   3. 调用updateContainer开始初始化更新
      - 计算更新优先级lane，老版本用的是expirationTime
      - 然后创建一个 `update` ，通过 `enqueueUpdate` 把当前的 update 放入到待更新队列 `updateQueue` 中。
   4. 用的是 **`unbatch`** （非批量的情况），并不是批量更新的 `batchUpdate` 。
   5. 接下来开始调用 `scheduleUpdateOnFiber` ，开始进入调度更新流程中。
      - scheduleSyncCallback 做的事情如下：
      - 如果执行队列为空，那么把当前任务放入队列中。然后执行调度任务。
      - 如果队列不为空，此时已经在调度中，那么不需要执行调度任务，只需要把当前更新放入队列中就可以，调度中心会一个个按照顺序执行更新任务。

1.  更新入口 scheduleUpdateOnFiber
   1. 在 `unbatch` 情况下，会直接进入到 performSyncWorkOnRoot ，接下来会进入到 **调和流程**，比如 `render` ，`commit`。
      - performSyncWorkOnRoot：这个方法会直接进入到调和阶段，会从 rootFiber 开始向下遍历
   2. 那么任务是 `useState` 和 `setState`，那么会进入到 `else` 流程，那么会进入到 `ensureRootIsScheduled` 调度流程。
      - `ensureRootIsScheduled`会进入到调度流程。
   3. 当前的执行任务类型为 `NoContext` ，说明当前任务是非可控的，那么会调用 `flushSyncCallbackQueue` 方法。
      - `flushSyncCallbackQueue`：用于立即执行更新队列里面的任务

**ensureRootIsScheduled**

- 首先会计算最新的调度更新优先级 `newCallbackPriority`，接下来获取当前 root 上的 `callbackPriority` 判断两者是否相等。如果两者相等，那么将直接退出不会进入到调度中。

- 如果不想等那么会真正的进入调度任务 `scheduleSyncCallback` 中。注意的是放入调度中的函数就是**调和流程**的入口函数 `performSyncWorkOnRoot`。

- 函数最后会将 newCallbackPriority 赋值给 callbackPriority

### **什么情况下会存在 existingCallbackPriority === newCallbackPriority，退出调度的情况？**

如果在正常模式下（非异步）一次更新中触发了多次 `setState` 或者 `useState` ，那么第一个 setState 进入到 ensureRootIsScheduled 就会有 root.callbackPriority = newCallbackPriority，那么接下来如果还有 setState | useState，那么就会退出，将不进入调度任务中，**原来这才是批量更新的原理，多次触发更新只有第一次会进入到调度中**

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU1OTg2ZjI2ZGU4YjI3ZjY3MTJhN2UwOWQ1YWUyNGVfVFZCa3l5d0o5Z0hIaGhiWGZtaml4VzlyT05MVFkwNlJfVG9rZW46Ym94Y25KdTRGWmx1TFZvaGJsb1RBUGl0VTRnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 调度流程图

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y1YTc0MzAzMjMyMWVlZDQ5NDQwNTc1MTFjN2Y0NTVfY3ByWlVsN2ZXdlRJa0Y3V09KMlpjUVRVdXZMVXREMmVfVG9rZW46Ym94Y256S0h4RUZURGdCRmQyMUo3dlp1emJkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 调和+异步调度 流程总图

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NTliYWNhM2ExNDdlMTYzODRiZTU4MTJhNDdlNDc1YTlfRWlxTkF0SWdHNVY0RXh4UnVPakFBTW11MWN2SUhqakhfVG9rZW46Ym94Y25JdUt1akVCMWVCVFl5ZGg5RFZUZVdlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

暂时无法在飞书文档外展示此内容

暂时无法在飞书文档外展示此内容

调度主要处理的是堆积的任务，当只有一个任务进入的时候会立刻执行该任务

整个调度被requestHostCallback包裹在异步任务当中并初始化全局变量

设置全局标记表示当前已经进入调度执行状态中

开始循环消费任务队列，取出最小堆中最前面的任务执行 task.callback

1. 任务执行中断（这种情况会出现在 fiber 树过大导致在当前渲染帧中无法全部生成，只能先暂停并返回剩余任务）
   1. 接收剩余任务，并将当前 task.callback 赋值为返回的剩余任务等待下次执行
   2. 退出调度循环，返回true代表队列未被清空
   3. 任务执行完成
      1. 将执行完成的任务踢出 taskQueue，获取下一个优先级最低的任务
      2. 继续调度循环，执行下一个 task.callback
      3. 任务队列为空时说明所有 task 均已被执行完成，退出调度循环并返回false代表队列已清空

根据消费结果判断

- 结果为false代表队列清空，直接退出，等待接收任务
  - 结果为true代表task队列中还有需要完成的任务，重新发起新的调度

更多

13:29

好嘞

更多

## 时间分片

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ1Njg2MTA4NjcwYTRlNWYxMWRmMWU3MTVmZmRjM2RfOHM0U054cnNXbU14UThJMkM3WlV4TGR6bzk2MjF4ZEhfVG9rZW46Ym94Y25JTHVEbjBvRVFzT0JRem5vdm1ydTBjXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

## 虚拟列表

在长列表滚动的时候，只有视图区域显示的是真实dom，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEyNmQ0ZDNjMWYzZGZkYmNlZDVlZjIyZDIyYWY4NThfSEVTSGpoWFdSVFd3U05neDZ6YjBQczJpdDIzc1hMczZfVG9rZW46Ym94Y25xNk9vQXo3U0RHQU1Oczl6aDhnOW9iXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- 视图区：视图区就是能够直观看到的列表区，此时的元素都是真实的 DOM 元素

- 缓冲区：缓冲区是为了防止用户上滑或者下滑过程中，出现白屏等效果。（缓冲区和视图区为渲染真实的 DOM ）

- 虚拟区：对于用户看不见的区域（除了缓冲区），剩下的区域，不需要渲染真实的 DOM 元素。虚拟列表就是通过这个方式来减少页面上 DOM 元素的数量。

## 渲染控制

### 从父组件直接隔断子组件的渲染

1. 缓存element来避免没有必要的更新
   1. ```JavaScript
      export default class Index extends React.Component{
          constructor(props){
              super(props)
              this.state={
                  numberA:0,
                  numberB:0,
              }
              this.component =  <Children number={this.state.numberA} />
          }
          controllComponentRender=()=>{ /* 通过此函数判断 */
              const { props } = this.component
              if(props.number !== this.state.numberA ){ 
                  /* 只有 numberA 变化的时候，重新创建 element 对象  */
                  return this.component = React.cloneElement(this.component,{ number:this.state.numberA })
              }
              return this.component
          }
          render(){
             return <div>
                { this.controllComponentRender()  } 
                <button onClick={ ()=> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA</button>
                <button onClick={ ()=> this.setState({ numberB:this.state.numberB + 1 }) }  >改变numberB</button>
            </div>
          }
      }
      ```

   2.  每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 `pendingProps` ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新

   3. **使用React.useMemo**

   4. ```JavaScript
      export default function Index(){
          const [ numberA , setNumberA ] = React.useState(0)
          const [ numberB , setNumberB ] = React.useState(0)
          return <div>
              { useMemo(()=> <Children number={numberA} />,[ numberA ]) }
              <button onClick={ ()=> setNumberA(numberA + 1) } >改变numberA</button><button onClick={ ()=> setNumberB(numberB + 1) } >改变numberB</button></div>
      }
      ```

1. React.memo
   1.  React.memo 可作为一种容器化的控制渲染方案，可以对比 props 变化，来决定是否渲染组件.

   2.  React.memo 接受两个参数：

   3. 第一个参数 Component 原始组件本身
   4. 第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。返回 true 组件不渲染 ， 返回 false 组件重新渲染。当二个参数 compare 不存在时，会用**浅比较原则**处理 props ，相当于仅比较 props 版本的 pureComponent 。
   5. memo 同样适合类组件和函数组件。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGMwMjU4YWIyMmEzMjY5ZjRiM2U2YzQyMmRiYTAxNGRfdUR0OUlkdGRHelZWTDFxTXpUZTdWcVRtMEhaTGx0MkFfVG9rZW46Ym94Y25ISXZFME1qTTFZaFF5QjhNQThJSkFiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

### 组件从自身来控制是否render

1. PureComponent：**浅比较 state 和 props 是否相等**
   1.  **PureComponent 原理及其浅比较原则**

   2. PureComponent 内部是如何工作的呢？
      1.   shouldComponentUpdate 的权重，会大于 PureComponent

      2.   首先当选择基于PureComponent继承的组件。原型链上会有 isPureReactComponent属性，该属性会在更新组件updateClassInstance方法中使用，判断当前组件是不是纯组件的，这个函数在更新组件的时候被调用，该函数内部，有一个专门负责检查是否更新的函数checkShouldComponentUpdate。
   3. PureComponent注意事项
      1. 避免使用箭头函数：不要给是 PureComponent 子组件绑定箭头函数，因为父组件每一次 render ，如果是箭头函数绑定的话，都会重新生成一个新的箭头函数， PureComponent 对比新老 props 时候，因为是新的函数，所以会判断不想等，而让组件直接渲染，PureComponent 作用终会失效。
      2. PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理
         1.    在用 class + function 组件开发项目的时候，如果父组件是函数，子组件是 PureComponent ，那么绑定函数要小心，因为函数组件每一次执行，如果不处理，还会声明一个新的函数，所以 PureComponent 对比同样会失效

         2. ```JavaScript
            class Index extends React.PureComponent{}
            export default function (){
                const callback = function handerCallback(){} /* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */
                return <Index callback={callback}  />
            }
            export default function (){
                const callback = React.useCallback(function handerCallback(){},[])
                return <Index callback={callback}  />
            }
            ```
   4. shallowEqual浅比较流程：
      1. 首先会直接比较新老 props 或者新老 state 是否相等。如果相等那么不更新组件
      2. 判断新老 state 或者 props ，有不是对象或者为 null 的，那么直接返回 false ，更新组件。
      3. 通过 Object.keys 将新老 props 或者新老 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。
      4. 遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 false ，更新组件。 到此为止，浅比较流程结束， PureComponent 就是这么做渲染节流优化的。

1. shouldComponentUpdate

### 什么时候需要注意渲染节流

1. 数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。

- 含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。

- 第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。

## React事件和普通的html事件有什么不同

- 原生事件为全小写，react事件采用小驼峰

- 对于时间函数处理语法，原生事件为字符串，react事件为函数

- react事件不能采用return false的方式来阻止浏览器的默认行为，而必须要明确的调用preventDefault()来阻止默认行为

合成事件是react模拟原生dom事件所有能力的一个事件对象。

合成事件的优点：

- 兼容所有浏览器，更好的跨平台

- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）

- 方便react统一管理和事务机制

事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。

## 事件机制

[谈谈React事件机制和未来(react-events) - 掘金](https://juejin.cn/post/6844903905382367245)

[React 事件机制解析 - 掘金](https://juejin.cn/post/7126733601533591582)

React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent），合成事件不会直接映射到原生事件，通过 registrationNameDependencies来记录合成事件和原生事件的映射关系。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE4ZGJhY2Y2OWMzOTM3Mjc2NGE3YzQ3NDgxZDBmMjNfazJEcnhYVmRhOWxVWHJtaHpQcE54Mk03R3RHOEl0OVFfVG9rZW46Ym94Y245OUlCYmtDY2hWTzRuY2RuNE8yMjVnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

SyntheticEventPlugin将事件类型化为了三类，对应不同的优先级：

- DiscreteEvent离散事件，例如blur，focus，click等

- UserBlockingEvent用户阻塞事件，例如touchMove，mouseMove，scroll，drag等。这些事件会阻塞用户的交互

- ContinuousEvent可连续事件，例如load，error等这个优先级最高，他们应该是立即同步执行的，可连续的，不能打断的

**React事件机制中的插件协议：**

```JavaScript
export type DispatchConfig = {
// 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇
  dependencies: Array<TopLevelType>,
  // 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器            
  phasedRegistrationNames?: {  
  // 冒泡阶段, 如onClick  
      bubbled: string, 
  // 捕获阶段，如onClickCapture 
      captured: string,   
  },
  // props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationName
  registrationName?: string 
  // 事件的优先级
  seventPriority: EventPriority,  
       
};

export type EventTypes = {[key: string]: DispatchConfig};

// 插件接口
export type PluginModule<NativeEvent> = {
  // 声明插件支持的事件类型
  eventTypes: EventTypes,   
  // 对事件进行处理，并返回合成事件对象       
  extractEvents: (                 
    topLevelType: TopLevelType,
    targetInst: null | Fiber,
    nativeEvent: NativeEvent,
    nativeEventTarget: EventTarget,
  ) => ?ReactSyntheticEvent,
  tapMoveThreshold?: number,
};
```

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VkNDA2NzQ2MDRjY2VlNzJmNjAwNDc3ZTZiMDBlNjdfM2RkS2cyb0kxbGZETVV6bVVSdndSejJRdG5nYmNTd1pfVG9rZW46Ym94Y243a3NzZDIwdVFmU3BhV2g0Z2pNbTJnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MGNmZjc2ZTRhZmVhMDk0ODU2MzQ1N2JiZjdmYmY1ZWNfSm05aHpIbVhnTlJmd2VxZHVYdmNVYWM1TE56aGZiVjRfVG9rZW46Ym94Y24wZlZyS1JwR1ZpRTZ6elVaMmZ3aHRkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

事件绑定：

1. 在props初始化和更新时会进行事件绑定，首先react会判断元素是否是媒体类型，媒体类型是无法在document监听的，所以会直接在元素上绑定

1. 反之就在document上绑定，需要的事件依赖列表以及ReactBroswerEventEmitter维护的已订阅事件表

事件分发：

不同的事件类型有不同的事件处理器，他们的调度优先级不一样。最终不同的事件类型都会调用dispatchEvent函数，在该函数中会从dom原生事件对象获取事件触发的target，再根据这个target获取关联的react节点实例，接着会调用EventPluginHub的runExtractedPluginEventsInBatch，这个方法遍历插件列表来处理事件，生成一个SyntheticEvent列表，runEventInBatch批量执行这些事件中的事件队列

SyntheticEvent的extraEvents主要做以下三件事：

- 根据事件的类型确定SyntheticEvent子类事件构造器

- 构造SynthticEvent对象

- 根据dom事件传播的顺序获取用户事件处理器列表

**为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用**。所以在事件处理器同步执行完后，SyntheticEvent对象就会马上被回收，所有属性都会无效，所以一般不在意不操作中访问SyntheticEvent事件对象

保持事件对象的引用：

- 调用`SyntheticEvent#persist()`方法，告诉React不要回收到对象池

- 直接引用`SyntheticEvent#nativeEvent`, nativeEvent是可以持久引用的，不过为了不打破抽象，建议不要直接引用nativeEvent

## React fiber

https://juejin.cn/post/6844903975112671239#%E7%B1%BB%E6%AF%94%E6%B5%8F%E8%A7%88%E5%99%A8javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83

并发：一个进程分成了多个线程

并行：同时处理多个任务

1. ### react为什么要引入fiber架构？

Reconcilation（协调）：react递归比对virtualDom树，找出需要变动的节点，然后同步更新他们。该过程是CPU密集型的操作。

为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率

所以通过React Fiber架构，让自己的reconcilation过程变成可中断，适时地让出CPU执行权

优点：

- 可以让浏览器即时的响应用户的交互

- 分批延时对dom进行操作，可以得到更好的用户体验

- 给浏览器一点喘息的机会，可以对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正

1. ### 什么是fiber

   - 一种流程控制原语
     1.   Fiber也称协程或者纤程。协程本身不具有并发或者并行的能力，只是一种控制流程的让出机制。

     2. react与浏览器之间的关系？
        -    **React fiber的思想：React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染**。

        -    合作式调度：

        - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA2M2MyNjM5MzQ3MmIxMzM5ZTI2NzQ0NGRiNTc0ODdfUlJmMkxZSUtxQlM2MnFMbTJUUUl5UTdVNlhVdmxRdmFfVG9rZW46Ym94Y256NEdJdEVrMVNFQ25KdWVabjdHVlFmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)
     3. **怎么确定有高优先任务要处理？**
        -    我们无法判断当前执行的任务是否具有高优先级，所以我们可以通过超市检查的机制来让出控制权。即：**确定一个合理的运行时长，然后在合适的检查点检测是否超时，如果超时就停止执行，将控制权交还给浏览器**

        -    **让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。**

        -    浏览器在一帧内可能会做执行下列任务，按顺序：

        - 处理用户输入事件
        - js执行
        - requestAnimation调用
        - 布局layout
        - 绘制paint
        -    如果浏览器处理完上述的任务还有盈余事件，浏览器就会调用requestIdleCallbak的回调
   - 一个执行单元
     1.   fiber的另一种解读是纤维，这是一种数据结构或者说执行单元，每次执行完一个执行单元，react就会检查现在还剩多少时间，如果没有时间就将控制权让出去

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ2MzVlMTdhZjM2ZTRmYzdhMmY1NmRmODVmNzQ2NmZfTnhLVkg2bVY3M3B3VjlOY0Z4Y2IyVVVXMTVKVkJZUDFfVG9rZW46Ym94Y250bEk3N0xWQmlXTkFSaWxSWEFXcVZuXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

react目前的做法是使用链表，每个VirtualDOM节点内部现在使用Fiber表示，所以即使处理流程被中断了，我们随时可以从上次未处理完的`Fiber`继续遍历下去。

每次渲染的两个阶段，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。因为协调阶段可能被中断、恢复，甚至重做，**React 协调阶段的生命周期钩子可能会被调用多次!**,所以不要在协调阶段包含副作用

- **协调阶段：**
  -  可以理解为diff阶段，这个阶段可以被中断，这个阶段会找出所有节点变更（副作用），以下生命周期钩子会在协调阶段被调用

  - Construtor
  - componentWillMount  废弃
  - componentWillReceiveProps 废弃
  - static getDerivedStateFromProps
  - shouldComponentUpdate
  - componentWillUpdate 废弃
  - render

- **提交阶段：**
  -  将上一个阶段计算出来的需要处理的副作用一次性执行了，这个阶段必须同步执行，不能被打断，以下生命周期钩子会在提交阶段被调用：

  - getSnapshotBeforeUpdate()
  - componentDidMount
  - componentDidUpdate
  - componentWillUnmonut

Fiber包含的属性可以划分为5个部分：

- 结构信息：Fiber使用链表的形式来表示节点在树中的定位

- 节点类型信息：tag表示节点的分类，type保存具体的类型值

- 节点的状态：节点的组件实例，props，state，他们将影响组件的输出

- 副作用相关：在reconciliation过程中发现的副作用就保存在节点的effectTag中，在reconciliation过程中还会构建一颗新的树，可以认为表示当前工作进度的树，还有一颗表示已渲染的树，react就是一边和旧树比对，一边构建WIP树的

```JavaScript
// 单链表树结构
{
    return： Fiber | null,// 指向父节点
    child：Fiber | null，// 指向自己的第一个子节点
    sibling：Fiber ｜ null，//指向自己的兄弟结构，兄弟节点的return指向同一个父节点
}
```

## 图解react

- performSyncWorkOnRoot：fiber树构造，fiber构造过程中出现异常的异常处理，调用输出
  -  performConcurrentWorkOnRoot与performSyncWorkOnRoot的区别在于对于可中断渲染的支持。调用performConcurrentWorkOnRoot函数时，首先检查是否处于render过程中，是否需要恢复上一次渲染，如果本次渲染被中断，最后返回一个新的performConcurrentWorkOnRoot函数，等待下一次调用

- commitRoot：处理副作用队列，将最新的fiber树结构反映到dom上
  - acommitBeforeMutationEffects：dom变更之前，主要处理副作用队列中带有Snapshot，Passive标记的fiber节点
  - bcommitMutationEffects：dom变更，界面得到更新，主要处理副作用队列中带有Placement,Update，Deletion（要被删除），Hydrating标记的fiber节点
  - ccommitLayoutEffects：dom变更后，主要处理副作用队列中Update|Callback标记的fiber节点

# webpack&vite

[「吐血整理」再来一打Webpack面试题 - 掘金](https://juejin.cn/post/6844904094281236487)

[pitch](https://juejin.cn/post/6946008768702316558)

[juejin.cn](https://juejin.cn/post/6844904093463347208)

[happypack](https://juejin.cn/post/6844903780337582088)

## Source map是什么？生产环境怎么用？

source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

线上环境一般有三种处理方案：

1. `hidden-source-map`：借助第三方错误监控平台 Sentry 使用

1. `nosources-source-map`：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高

1. `sourcemap`：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)

## 文件监听原理

在发现源码发生变化时，自动重新构建出新的输出文件。

Webpack开启监听模式，有两种方式：

- 启动 webpack 命令时，带上 --watch 参数

- 在配置 webpack.config.js 中设置 watch:true

缺点：每次需要手动刷新浏览器

原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 `aggregateTimeout` 后再执行。

### 文件指纹是什么？怎么用？

文件指纹是打包后输出的文件名的后缀

- hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改

- chunkhash：和webpack打包的chunk有关，不同的entry会生出不同的chunkhash

- contenthash：根据文件内容来定义hash，文件内容不变，则contenthash不变

指纹设置：

1. js的文件指纹设置：设置output的filename，用chunkhash

1. css的文件指纹设置：设置 MiniCssExtractPlugin 的 filename，使用 contenthash。

1. 图片的文件指纹设置：设置file-loader的name，使用hash

## chunk&bundle

[Webpack 理解 Chunk - 掘金](https://juejin.cn/post/6844903889393680392)

Chunk是Webpack打包过程中，一堆module的集合。我们知道Webpack的打包是从一个入口文件开始，也可以说是入口模块，入口模块引用这其他模块，模块再引用模块。Webpack通过引用关系逐个打包模块，这些module就形成了一个Chunk。

bundle：我们最终输出的一个或多个打包文件

产生chunk的三种途径

1. entry入口
   1. 传递字符串，数组都只会产生一个chunk
   2. 传递对象：一个字段产生一个chunk吗所以在output中filename直接写死名称，会报错
   3. ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E0OTAwYjM0YWRkNzdmZmQxOTFhYzFkNzMxM2QxNjdfM2RPRHRJV2lXY3drektWaGlYYW1IWEhDV1hTRkZJMlNfVG9rZW46Ym94Y25hSDFlUjFuVEI1YzA5MUU5THJGWXVkXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

1. 异步加载模块

1. 代码分割

# 前端工程化

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJiNmFiYTM5ODY2NTMxN2Q5Y2Q5OTI1MDBjNGRjODBfbHNMdjNwUVA4YTdjTExaMUIzbkdlU0RRQmFtV0ZxNkRfVG9rZW46Ym94Y24wQ0loMUZ0SXlUYm5oSUJ4NkJjdnJiXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY0NDE3ZjY2MGFhODlhYTljZmViNzZkNTJmNDAwNjBfa25LTnBUelhkTDdnZmNwZ3pXRjhhdHZMZkg1cENoRlpfVG9rZW46Ym94Y24zM2ZzcFV6SU5McHlMMnFib3o2YnhnXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

# 等等

- 绑定域名
  -  因登陆状态有cookie的限制，需要绑定host【127.0.0.1 想要的名字.bytedance.net】map到本地服务

  -  在终端输入

  - ```Plaintext
    $ sudo vi /etc/hosts
    ```

  -  通过vim进行编辑，i进入输入模式，添加一行 127.0.0.1  想要的名字.bytedance.net后，esc退出，输入:wq保存并退出，在浏览器地址栏输入绑定的picotest.bytedance.net

  - ![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZlODViYTRhMTI5NWVkNWRmYmU0NTk3YzQ4MDU0NGVfTU9EcWVRZzNkV0dZdFpRWHhTUldvb29YaFlDYmwySFRfVG9rZW46Ym94Y255RWQwekh4TjBOaURHajhXNEg2OGMwXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- module-alias：路径替换。[前端工程化工具 ---- module-alias](https://www.jianshu.com/p/d9268465c4b8)

- https的域限制请求http的资源，所以积分管理页面中使用a标签点击跳转链接完成下载的时候不好使，需要服务端下发链接的时候为https

- ?? 空值合并运算符：当左侧的操作数为 `null` 或者 `undefined` 时，返回其右侧操作数，否则返回左侧操作数。
  - ```JavaScript
    const num = id ?? 1    // 当id为null或undefined时num等于1，否则num等于id
    ```

  -  || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值是无法达到预期的

  - > 不能与&&或||连用，会报错SyntaxError，因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的，如果想要配合使用需要使用()体现优先级

- mock：模拟接口，这种接口访问可以正常返回数据，但是不涉及逻辑以及数据库的操作

- 创建二维数组可以使用const arr = new Array(5).fill([])，但是此时如果arr[0][0] = 1,会使得该二维数组变成[[1],[1],[1],[1],[1]]，因为各位要清楚，当你给 fill 传递一个入参时，**如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用**

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ3ZjM0NmNmNjkzYTQ4NzU4ZGNlM2Q4OWJkMDM2ZGVfOVJldnVPZUpFajZ3UDFIWkhlNnRVck9NY00xSGhlMzVfVG9rZW46Ym94Y25URjZFSm40NnBHd0loM0lrSWNiTGZoXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

- 新clone一个项目代码的时候出现报错，解决方案https://blog.csdn.net/pro_fan/article/details/120457551

- 八位色值：#xxxxxxxx，前两位表示透明度

- 使用 `navigator.clipboard` 来访问系统剪切板 [Navigator.clipboard - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/clipboard)

- npx：node.js的包运行器[npx使用教程-阮一峰](https://www.ruanyifeng.com/blog/2019/02/npx.html) [Node.js 包运行器 npx](http://nodejs.cn/learn/the-npx-nodejs-package-runner)

# 计算机网络

暂时无法在飞书文档外展示此内容

暂时无法在飞书文档外展示此内容

## [get&post](https://cloud.tencent.com/developer/article/1498283)

## [HTTP3](https://zhuanlan.zhihu.com/p/431672713)

# Todo：

- [babel](https://babel.docschina.org/docs/en/usage/#plugins--presets)

- 命令行相关命令

- gitlab相关内容

- git相关操作
  -  解决冲突
  - 一些基本命令
  - git相关知识
  - 可视化工具使用

- 鹊桥jsb相关内容

- npm包发布

- charles以及相关代理工具的使用

- css module ，less等相关知识

- starling接入相关

- jupiter定位

- 业务流程总结

- 工作过程中的经验

- bam，byteio，scm等相关介绍

- npm link

- webview

- Lodash

- Classnames

- Module alias

- Tree shaking

- pinia

- nvm

- \#xxxxxxxx八位色值

- 多进程/线程打包 子编译，happpack，threadloader

前端学习：

- react

- webpack

- RFC

- ts
  - omit,pick,partial

- 基本知识沉淀记录

- 算法相关知识

- Pinia

- Nuxt

- node

- bff

- qps

- 爬虫，爬虫标识

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U1YTBjNTgxY2YxYjgxMDBlNGViOGNhZTBmMjQ2ZjdfWURCQXRFanNtUmNkWVAxVHNRNjVtS0lXajd1b0xnMVNfVG9rZW46Ym94Y25ENGdwcmFhNjZlMzFicERjb2VwSmFlXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

# 一些文档

[前端图书馆](https://bytedance.feishu.cn/wiki/wikcn9P9bPcFZWg1qZI4OTiYKuh#eLyw1D) 

[css module](https://bytedance.feishu.cn/docx/doxcnPAR8C9zYZiJldGd7EQDgyc) 

[jupiter项目/组件库接入starling](https://bytedance.feishu.cn/docx/doxcnygAyLw2d9O7wbJQp2JS4Sd) 

[git知识梳理](https://bytedance.feishu.cn/docx/doxcnOyJhoPoxmuvFVSgiYa8AAb) 

[Yellow_ice - 博客园](https://www.cnblogs.com/Yellow-ice)——[前端规范之Git工作流规范(Husky + Commitlint + Lint-staged) ](https://www.cnblogs.com/Yellow-ice/p/15349873.html)

https://github.com/yuanyuanbyte/Blog

暂时无法在飞书文档外展示此内容

## 小伙伴们的~

[Ecma International approves ECMAScript 2022: What’s new?](https://2ality.com/2022/06/ecmascript-2022.html)

https://mp.weixin.qq.com/s/WCQvPbd_w8P-Tn36Sc0SXQ

[解决鼠标移入子元素触发父元素的mouseout事件_EvanOne(文一)的博客-CSDN博客](https://blog.csdn.net/qq_41139830/article/details/82860616)

[智勇的掘金主页](https://juejin.cn/user/4068639272611079)

[李静 的个人主页 - 动态 - 掘金](https://juejin.cn/user/940837683346984)

https://juejin.cn/post/6933117111585734669

[og协议](https://juejin.cn/post/6933117111585734669)

![img](https://xj8dretytf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM3ZjBkMGM2OTRiNGU5MGFjOTA3NjhhMzY2ZWNjYmZfaU84clZqZFhTTkhNR1BIbTE2RG5JZFd1dkg5R2NZUEtfVG9rZW46Ym94Y25WS1AxQnhFTnlpWnFKQzd5bU1WdlBmXzE2Njc0NzE4NDU6MTY2NzQ3NTQ0NV9WNA)

[HTTPS相关问题](https://opensource.qduoj.com/#/onlinejudge/guide/https)

https://developer.chrome.com/docs/extensions/mv3/intro/mv3-overview/

一个知识点：跟移动端联调的时候发现 css 的 link 标签字段有 media 属性，可以用来实现暗黑模式的切换 => https://stackoverflow.com/questions/57203909/how-to-use-ios-13-darkmode-for-wkwebview

```Plain
<link rel="stylesheet" href="entry-content-dark.css" media="(prefers-color-scheme: dark)" id="dark-style">
```

https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

[学习指北：Node.js 2022 全解析](https://live.juejin.cn/4354/898051)

https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollBy

[2022年了，你还没用pnpm吗? - 掘金](https://juejin.cn/post/7121386382936768542)

debug node_modules 里的包应该用什么方法？

Restful

Pnpm

Node modules

Webp

打补丁

Pr

textmate

weex

webview

https://blog.csdn.net/Rao_Limon/article/details/100044392

[pnpm 是凭什么对 npm 和 yarn 降维打击的 - 掘金](https://juejin.cn/post/7127295203177676837)

https://github.com/gaearon/react-hot-loader

https://webpack.docschina.org/configuration/cache/

https://github.com/facebook/react/issues/16604

https://cloud.tencent.com/developer/article/1563717