# Typescript

## 原始类型与对象类型

1. js中null表示这里有值但是是个空值，undefined表示这里没有值；而在ts中null和undefined都是有具体意义的值，在没有开启strictNullChecks检查的情况下，会被视作其他类型的子类型
2. ts中void用于描述一个内部没有return语句，或者没有显示return一个值的函数的返回值
3. 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。具名元组可以为元组元素打上类似属性的标记

   ```js
   const arr7: [name: string, age: number, male: boolean] = ['linbudu', 599, true];
   ```
4. 数组与元组的区别

   - 只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读
   - 一旦被标记为只读，则这个只读数组/元组的类型上，将不再具有push，pop等会修改原数组的方法
5. readonly关键字：防止对象的属性被再次赋值
6. 在ts中Object包含所有的数据类型；object代表所有非原始类型的类型（数组，对象，函数）；{}也包含所有类型，但是不能对这个变量进行任何赋值操作
7. 在js中symbol代表一个唯一的值的类型，类似于字符串类型，可以作为对象的属性名，但是在ts中，symbol类型指的都是ts中的同一个类型。在ts中支持了unique symbol这一类型声明，他是symbol类型的子类型，每一个unique symbol类型都是独一无二的。在ts中，如果想要引用已创建的unique symbol类型，则需要适用类型查询操作符typeof

   ```js
   declare const uniqueSymbolFoo: unique:symbol;
   const uniqueSymbolBaz: typeof uniqueSymbolFoo = uniqueSymbolFoo
   ```

## 字面量类型和枚举

1. 字面量类型主要包括 字符串字面量类型 、 数字字面量类型 、布尔字面量类型和对象字面量类型
2. 联合类型 | ,代表了一组类型的可用集合

   1. 对于联合类型中的函数类型，需要使用括号（）包裹起来
   2. 函数类型并不存在字面量类型，因此这里的 `(() => {})` 就是一个合法的函数类型
   3. 你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中
3. 无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值 。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间
4. 枚举

   1. 如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后（如上例），或者放在第一位

      ```js
      enum Items {
        Foo = returnNum(),
        Bar = 599,
        Baz
      }
      // 或者
      enum items {
        Baz,
        Foo = returnNum(),
        Bar = 599,
      }
      ```
   2. 枚举和对象的区别：对象是单向映射的，我们只能从键映射到键值。而枚举是双向映射的。
   3. 仅有值为数字的枚举成员才能够进行这样的双向枚举，字符串枚举成员仍然会进行单次映射
   4. 如果你没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增

      ```
      enum Items {
        Foo, // 0
        Bar, // 1
        Baz  // 2
      }
      ```
